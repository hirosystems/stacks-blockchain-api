---
description: USE EVERY TIME you are doing any kind of system design or seeking to understand system organization or architecture. 
alwaysApply: false
---
# Architecture Rules for Stacks Blockchain API

## ARCHITECTURAL PHILOSOPHY

This Stacks blockchain API follows a **LAYERED ARCHITECTURE** with clear separation of concerns. Every architectural decision must prioritize:
- **RELIABILITY**: The system must handle blockchain data consistently and correctly
- **PERFORMANCE**: Support high throughput for blockchain queries and real-time updates
- **MAINTAINABILITY**: Enable safe evolution as the Stacks blockchain grows
- **SCALABILITY**: Handle increasing load without breaking existing functionality

## SYSTEM ARCHITECTURE OVERVIEW

### High-Level Architecture Pattern
```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   API Layer     │    │  WebSocket      │    │   Rosetta API   │
│   (Fastify)     │    │  Transmitter    │    │   (Express)     │
│                 │    │                 │    │                 │
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                       │                       │
         └───────────────────────┼───────────────────────┘
                                 │
                   ┌─────────────────┐
                   │  Controllers    │
                   │  (Business      │
                   │   Logic)        │
                   └─────────────────┘
                                 │
                   ┌─────────────────┐
                   │   Data Store    │
                   │   (pg-store)    │
                   └─────────────────┘
                                 │
                   ┌─────────────────┐
                   │  PostgreSQL     │
                   │   Database      │
                   └─────────────────┘
```

### Layer Responsibilities

#### 1. API Layer (`src/api/`)
- **Routes**: Define endpoints and parameter validation
- **Schemas**: TypeBox-based request/response validation  
- **Middleware**: Caching, authentication, rate limiting
- **Serializers**: Transform database models to API responses

#### 2. Controller Layer (`src/api/controllers/`)
- **Business Logic**: Coordinate between API and data layers
- **Validation**: Input sanitization and blockchain-specific validation
- **Caching Logic**: ETag generation and cache invalidation
- **Error Handling**: Transform database errors to API errors

#### 3. Data Access Layer (`src/datastore/`)
- **Query Building**: SQL query construction and execution
- **Result Parsing**: Transform database rows to typed objects
- **Transaction Management**: Database transaction coordination
- **Connection Management**: Database connection pooling and health

#### 4. Database Layer (PostgreSQL)
- **Data Storage**: Persistent blockchain data storage
- **Indexing**: Optimized queries for blockchain lookups
- **Constraints**: Data integrity enforcement
- **Migrations**: Schema evolution management

## CORE ARCHITECTURAL PRINCIPLES

### 1. Dependency Inversion
Follow strict dependency flow: API → Controllers → DataStore → Database

```typescript
// GOOD: Dependencies flow inward
class BlockController {
  constructor(private datastore: PgStore) {}
  
  async getBlock(params: BlockParams): Promise<Block> {
    const result = await this.datastore.getBlock(params);
    return this.transformToApiResponse(result);
  }
}

// BAD: Controller knows about API details
class BlockController {
  async getBlock(req: FastifyRequest, reply: FastifyReply) {
    // Controller should not know about HTTP details
  }
}
```

### 2. Single Responsibility Principle
Each layer has one clear responsibility:

```typescript
// GOOD: Route only handles HTTP concerns
fastify.get('/blocks/:hash', {
  schema: BlockSchema,
  preHandler: handleBlockCache,
}, async (req, reply) => {
  const block = await blockController.getBlock(req.params);
  await reply.send(block);
});

// GOOD: Controller handles business logic
class BlockController {
  async getBlock(params: BlockParams): Promise<Block> {
    this.validateBlockParams(params);
    const result = await this.datastore.getBlock(params);
    if (!result.found) {
      throw new NotFoundError('Block not found');
    }
    return this.transformBlock(result.result);
  }
}
```

### 3. Interface Segregation
Use focused interfaces rather than large monolithic ones:

```typescript
// GOOD: Focused interfaces
interface BlockDataAccess {
  getBlock(params: BlockParams): Promise<FoundOrNot<DbBlock>>;
  getBlocks(params: BlockListParams): Promise<DbPaginatedResult<DbBlock>>;
  getBlockTransactions(params: BlockTxParams): Promise<DbPaginatedResult<DbTx>>;
}

interface TransactionDataAccess {
  getTransaction(txId: string): Promise<FoundOrNot<DbTx>>;
  getTransactions(params: TxListParams): Promise<DbPaginatedResult<DbTx>>;
}

// BAD: Monolithic interface
interface DataAccess {
  // Everything mixed together
  getBlock(...): ...;
  getTransaction(...): ...;
  updateMempool(...): ...;
  processEvent(...): ...;
}
```

## DATA FLOW PATTERNS

### 1. Request Processing Flow
All API requests follow this pattern:

```typescript
// 1. Route Definition with Schema
fastify.get('/blocks/:height_or_hash', {
  schema: {
    params: BlockParamsSchema,
    response: { 200: BlockSchema },
  },
  preHandler: handleBlockCache,  // 2. Middleware
}, async (req, reply) => {
  // 3. Parameter Processing
  const params = parseBlockParam(req.params.height_or_hash);
  
  // 4. Controller Call
  const block = await fastify.db.v2.getBlock(params);
  
  // 5. Error Handling
  if (!block) {
    throw new NotFoundError('Block not found');
  }
  
  // 6. Response Transformation
  await reply.send(parseDbNakamotoBlock(block));
});
```

### 2. Database Query Pattern
All database queries follow this pattern:

```typescript
// 1. Column Selection
const results = await this.sql<BlockQueryResult[]>`
  SELECT ${this.sql(BLOCK_COLUMNS)}  // Use constants
  FROM blocks
  WHERE canonical = true             // Always filter canonical
    AND microblock_canonical = true
    AND block_height <= ${maxHeight} // Use parameters
  ORDER BY block_height DESC         // Consistent ordering
  LIMIT ${limit}
  OFFSET ${offset}
`;

// 2. Result Parsing
const parsed = results.map(r => parseBlockQueryResult(r));

// 3. Return Typed Result
return { results: parsed, total, limit, offset };
```

### 3. Error Handling Pattern
Use consistent error handling throughout:

```typescript
// 1. Input Validation
if (!isValidPrincipal(address)) {
  throw new InvalidRequestError(
    `invalid STX address "${address}"`,
    InvalidRequestErrorType.invalid_address
  );
}

// 2. Resource Not Found
if (!block.found) {
  throw new NotFoundError('Block not found');
}

// 3. Database Errors are handled by Fastify error handler automatically
```

## CACHING ARCHITECTURE

### 1. ETag-Based HTTP Caching
Use ETags for efficient client-side caching:

```typescript
// Cache Strategy by Resource Type
enum ETagType {
  chainTip = 'chain_tip',           // Based on latest block
  mempool = 'mempool',              // Based on mempool digest
  transaction = 'transaction',       // Based on tx status
  block = 'block',                  // Based on block hash + canonical status
  principal = 'principal',          // Based on address balance changes
}
```

### 2. Cache Invalidation Strategy
- **Chain Tip Changes**: Invalidate all chain-dependent caches
- **New Blocks**: Invalidate block-specific and address-specific caches  
- **Mempool Changes**: Invalidate mempool-dependent caches
- **Reorgs**: Invalidate all caches (safety measure)

### 3. Cache Headers Pattern
```typescript
// Cache Control Headers
if (etag) {
  if (ifNoneMatch && typeof etag === 'string' && ifNoneMatch.includes(etag)) {
    await reply.header('Cache-Control', CACHE_CONTROL_MUST_REVALIDATE).code(304).send();
  } else if (typeof etag === 'string') {
    void reply.headers({ 
      'Cache-Control': CACHE_CONTROL_MUST_REVALIDATE, 
      ETag: `"${etag}"` 
    });
  }
}
```

## SECURITY ARCHITECTURE

### 1. Input Validation Layers
Multiple layers of validation:

```typescript
// Layer 1: Schema Validation (TypeBox)
schema: {
  params: Type.Object({
    address: AddressParamSchema,  // Regex validation
  }),
  querystring: Type.Object({
    limit: LimitParam(ResourceType.Block),
  }),
}

// Layer 2: Business Logic Validation
if (!isValidPrincipal(address)) {
  throw new InvalidRequestError(
    `invalid STX address "${address}"`,
    InvalidRequestErrorType.invalid_address
  );
}

// Layer 3: Database Parameter Binding (prevents SQL injection)
const results = await this.sql`
  SELECT * FROM addresses WHERE address = ${address}
`;
```

### 2. Rate Limiting Strategy
Implemented at infrastructure level with circuit breakers:

```typescript
// Rate limiting patterns
- Global rate limiting per IP
- Endpoint-specific rate limiting for expensive operations
- User-based rate limiting for authenticated endpoints
- Circuit breakers for external service calls
```

### 3. Data Sanitization
Ensure all blockchain data is properly validated:

```typescript
// Hex String Validation
function validateRequestHexInput(hash: string) {
  try {
    const buffer = hexToBuffer(hash);
    if (buffer.toString('hex') !== hash.substring(2).toLowerCase()) {
      throw new Error('Invalid hash characters');
    }
  } catch (error: any) {
    throw new InvalidRequestError(error.message, InvalidRequestErrorType.invalid_hash);
  }
}

// Principal Validation  
function validatePrincipal(stxAddress: string) {
  if (!isValidPrincipal(stxAddress)) {
    throw new InvalidRequestError(
      `invalid STX address "${stxAddress}"`,
      InvalidRequestErrorType.invalid_address
    );
  }
}
```

## PERFORMANCE ARCHITECTURE

### 1. Database Optimization
- **Indexes**: All frequently queried columns have appropriate indexes
- **Query Optimization**: Use EXPLAIN ANALYZE to verify query plans
- **Connection Pooling**: Managed by `postgres` client with appropriate pool sizes
- **Read Replicas**: Support for read-only database replicas

### 2. Pagination Strategy
Consistent pagination across all list endpoints:

```typescript
// Cursor-based Pagination for Large Datasets
interface PaginationParams {
  limit: number;          // Items per page
  offset?: number;        // Traditional offset
  cursor?: string;        // Cursor for large datasets
}

// Resource-Type Based Limits
enum ResourceType {
  Block,      // limit: 30,  default: 20
  Tx,         // limit: 50,  default: 20  
  Event,      // limit: 100, default: 20
}
```

### 3. Query Optimization Patterns
```typescript
// Use Column Constants
const results = await this.sql<BlockQueryResult[]>`
  SELECT ${this.sql(BLOCK_COLUMNS)}  // Pre-defined column list
  FROM blocks
  WHERE canonical = true
  ORDER BY block_height DESC
`;

// Efficient Joins with Prefixed Columns
const results = await this.sql`
  SELECT ${this.sql([
    'blocks.block_hash',
    'blocks.block_height',
    ...prefixedCols(TX_COLUMNS, 'txs'),
  ])}
  FROM blocks
  INNER JOIN txs ON blocks.block_hash = txs.block_hash
`;
```

## SCALABILITY ARCHITECTURE

### 1. Horizontal Scaling Patterns
- **Read-Only Mode**: API instances can run in read-only mode for scaling reads
- **Write-Only Mode**: Dedicated instances for processing blockchain events
- **Load Balancing**: Multiple API instances behind load balancer
- **Database Scaling**: Read replicas for query distribution

### 2. Microservice Boundaries
While currently monolithic, the architecture supports future microservice extraction:

```typescript
// Potential Service Boundaries
- Block Service: Block and microblock data
- Transaction Service: Transaction processing and queries  
- Address Service: Address balance and transaction history
- WebSocket Service: Real-time notifications
- Search Service: Cross-entity search functionality
```

### 3. Resource Management
```typescript
// Resource Type Classification
enum ResourceType {
  Block,           // Immutable after finalization
  Transaction,     // Immutable after confirmation  
  Mempool,        // Highly volatile
  Address,        // Changes with transactions
  Search,         // Computed on demand
}

// Different caching and scaling strategies per resource type
```

## MONITORING & OBSERVABILITY ARCHITECTURE

### 1. Metrics Collection
```typescript
// Prometheus Metrics
- API request rates and latencies by endpoint
- Database query performance and connection pool metrics
- Cache hit/miss ratios by cache type
- WebSocket connection counts and message rates
- Blockchain synchronization lag and event processing rates
```

### 2. Logging Strategy
```typescript
// Structured Logging with Pino
const logger = pino({
  level: 'info',
  formatters: {
    level: (label) => ({ level: label }),
  },
});

// Log Correlation
- Request ID tracking through all layers
- Transaction ID correlation for blockchain operations
- Error context preservation through the stack
```

### 3. Health Checking
```typescript
// Health Check Hierarchy
/extended/v1/status - API health with database connectivity
- Chain tip information
- Database connection status  
- Stacks node connectivity
- Last processed block information
```

## DEPLOYMENT ARCHITECTURE

### 1. Environment Management
```typescript
// Environment Configuration
- Development: Single instance with all components
- Staging: Production-like with reduced resources
- Production: High availability with redundancy
```

### 2. Database Migration Strategy
```typescript
// Migration Pattern
1. Schema changes in migrations/ directory
2. Backward-compatible changes preferred
3. Event replay capability for major schema changes
4. Rollback procedures for each migration
```

### 3. Rolling Deployment Pattern
```typescript
// Zero-Downtime Deployment
1. Deploy new instances in read-only mode
2. Verify health and functionality
3. Switch traffic to new instances
4. Gracefully shutdown old instances
5. Monitor for issues and rollback if needed
```

## INTEGRATION EXAMPLES

### Full Request Flow Example
```typescript
// 1. API Route receives request
app.get('/v2/blocks/:block_id', async (req, reply) => {
  // 2. Controller handles caching
  await handleCache(req, reply);
  
  // 3. Parameter validation via schema
  const { block_id } = BlockParamSchema.parse(req.params);
  
  // 4. DataStore query with patterns
  const block = await req.server.db.getBlock({ 
    type: parseBlockParam(block_id) 
  });
  
  // 5. Response serialization
  return serializeBlock(block);
});
```

### Cross-Layer Data Flow
```typescript
// API Layer → Parameter validation & HTTP concerns
interface BlockRequest {
  block_id: BlockParam;
  include_txs?: boolean;
}

// Controller Layer → Business logic & caching  
class BlockController {
  async getBlock(params: BlockRequest): Promise<Block> {
    // Business validation + cache check
  }
}

// DataStore Layer → Database queries
class PgStore {
  async getBlock(query: DbBlockQuery): Promise<DbBlock> {
    // SQL query with canonical filters
  }
}
```

### Error Flow Integration
```typescript
// Database error → API error transformation
try {
  const block = await db.getBlock(query);
} catch (error) {
  if (error.code === 'ECONNREFUSED') {
    throw new ServiceUnavailableError('Database temporarily unavailable');
  }
  if (error.message.includes('invalid block hash')) {
    throw new InvalidRequestError('Invalid block identifier');
  }
  throw new InternalServerError('Unexpected error occurred');
}
```

## ARCHITECTURAL DECISION RECORDS (ADRs)

### Documenting Architectural Decisions
All significant architectural decisions MUST be documented following this template:

```markdown
# ADR-001: [Decision Title]

## Status
[Proposed | Accepted | Deprecated | Superseded]

## Context
[What is the issue that we're seeing that is motivating this decision?]

## Decision
[What is the change that we're proposing or have agreed to?]

## Consequences
[What becomes easier or more difficult to do because of this change?]

## References
- [Related ADRs]
- [External references]
```

### Current Architectural Decisions
1. **ADR-001**: Use TypeBox for schema validation over other alternatives
2. **ADR-002**: Implement ETag-based caching for HTTP responses
3. **ADR-003**: Use `postgres` client over other database libraries
4. **ADR-004**: Separate V1 and V2 API versions with different routing

## ARCHITECTURE EVOLUTION GUIDELINES

### 1. Adding New Features
- Follow existing layering patterns
- Add appropriate tests at each layer
- Document any new architectural patterns
- Consider impact on existing caching strategy

### 2. Performance Optimization
- Measure before optimizing
- Consider caching strategy impact
- Maintain backward compatibility
- Document performance characteristics

### 3. Breaking Changes
- **Prohibited** in existing API versions
- Create new API version if necessary
- Provide migration path for consumers
- Deprecation warnings for old versions

### 4. External Dependencies
- Evaluate stability and maintenance
- Consider lock-in implications
- Have fallback/migration strategies
- Document integration patterns

Remember: **Architecture serves the business needs** of providing reliable, fast access to Stacks blockchain data. Every architectural decision should be evaluated against this primary goal while maintaining the ability to evolve safely over time.
# Architecture Rules for Stacks Blockchain API

## ARCHITECTURAL PHILOSOPHY

This Stacks blockchain API follows a **LAYERED ARCHITECTURE** with clear separation of concerns. Every architectural decision must prioritize:
- **RELIABILITY**: The system must handle blockchain data consistently and correctly
- **PERFORMANCE**: Support high throughput for blockchain queries and real-time updates
- **MAINTAINABILITY**: Enable safe evolution as the Stacks blockchain grows
- **SCALABILITY**: Handle increasing load without breaking existing functionality

## SYSTEM ARCHITECTURE OVERVIEW

### High-Level Architecture Pattern
```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   API Layer     │    │  WebSocket      │    │   Rosetta API   │
│   (Fastify)     │    │  Transmitter    │    │   (Express)     │
│                 │    │                 │    │                 │
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                       │                       │
         └───────────────────────┼───────────────────────┘
                                 │
                   ┌─────────────────┐
                   │  Controllers    │
                   │  (Business      │
                   │   Logic)        │
                   └─────────────────┘
                                 │
                   ┌─────────────────┐
                   │   Data Store    │
                   │   (pg-store)    │
                   └─────────────────┘
                                 │
                   ┌─────────────────┐
                   │  PostgreSQL     │
                   │   Database      │
                   └─────────────────┘
```

### Layer Responsibilities

#### 1. API Layer (`src/api/`)
- **Routes**: Define endpoints and parameter validation
- **Schemas**: TypeBox-based request/response validation  
- **Middleware**: Caching, authentication, rate limiting
- **Serializers**: Transform database models to API responses

#### 2. Controller Layer (`src/api/controllers/`)
- **Business Logic**: Coordinate between API and data layers
- **Validation**: Input sanitization and blockchain-specific validation
- **Caching Logic**: ETag generation and cache invalidation
- **Error Handling**: Transform database errors to API errors

#### 3. Data Access Layer (`src/datastore/`)
- **Query Building**: SQL query construction and execution
- **Result Parsing**: Transform database rows to typed objects
- **Transaction Management**: Database transaction coordination
- **Connection Management**: Database connection pooling and health

#### 4. Database Layer (PostgreSQL)
- **Data Storage**: Persistent blockchain data storage
- **Indexing**: Optimized queries for blockchain lookups
- **Constraints**: Data integrity enforcement
- **Migrations**: Schema evolution management

## CORE ARCHITECTURAL PRINCIPLES

### 1. Dependency Inversion
Follow strict dependency flow: API → Controllers → DataStore → Database

```typescript
// GOOD: Dependencies flow inward
class BlockController {
  constructor(private datastore: PgStore) {}
  
  async getBlock(params: BlockParams): Promise<Block> {
    const result = await this.datastore.getBlock(params);
    return this.transformToApiResponse(result);
  }
}

// BAD: Controller knows about API details
class BlockController {
  async getBlock(req: FastifyRequest, reply: FastifyReply) {
    // Controller should not know about HTTP details
  }
}
```

### 2. Single Responsibility Principle
Each layer has one clear responsibility:

```typescript
// GOOD: Route only handles HTTP concerns
fastify.get('/blocks/:hash', {
  schema: BlockSchema,
  preHandler: handleBlockCache,
}, async (req, reply) => {
  const block = await blockController.getBlock(req.params);
  await reply.send(block);
});

// GOOD: Controller handles business logic
class BlockController {
  async getBlock(params: BlockParams): Promise<Block> {
    this.validateBlockParams(params);
    const result = await this.datastore.getBlock(params);
    if (!result.found) {
      throw new NotFoundError('Block not found');
    }
    return this.transformBlock(result.result);
  }
}
```

### 3. Interface Segregation
Use focused interfaces rather than large monolithic ones:

```typescript
// GOOD: Focused interfaces
interface BlockDataAccess {
  getBlock(params: BlockParams): Promise<FoundOrNot<DbBlock>>;
  getBlocks(params: BlockListParams): Promise<DbPaginatedResult<DbBlock>>;
  getBlockTransactions(params: BlockTxParams): Promise<DbPaginatedResult<DbTx>>;
}

interface TransactionDataAccess {
  getTransaction(txId: string): Promise<FoundOrNot<DbTx>>;
  getTransactions(params: TxListParams): Promise<DbPaginatedResult<DbTx>>;
}

// BAD: Monolithic interface
interface DataAccess {
  // Everything mixed together
  getBlock(...): ...;
  getTransaction(...): ...;
  updateMempool(...): ...;
  processEvent(...): ...;
}
```

## DATA FLOW PATTERNS

### 1. Request Processing Flow
All API requests follow this pattern:

```typescript
// 1. Route Definition with Schema
fastify.get('/blocks/:height_or_hash', {
  schema: {
    params: BlockParamsSchema,
    response: { 200: BlockSchema },
  },
  preHandler: handleBlockCache,  // 2. Middleware
}, async (req, reply) => {
  // 3. Parameter Processing
  const params = parseBlockParam(req.params.height_or_hash);
  
  // 4. Controller Call
  const block = await fastify.db.v2.getBlock(params);
  
  // 5. Error Handling
  if (!block) {
    throw new NotFoundError('Block not found');
  }
  
  // 6. Response Transformation
  await reply.send(parseDbNakamotoBlock(block));
});
```

### 2. Database Query Pattern
All database queries follow this pattern:

```typescript
// 1. Column Selection
const results = await this.sql<BlockQueryResult[]>`
  SELECT ${this.sql(BLOCK_COLUMNS)}  // Use constants
  FROM blocks
  WHERE canonical = true             // Always filter canonical
    AND microblock_canonical = true
    AND block_height <= ${maxHeight} // Use parameters
  ORDER BY block_height DESC         // Consistent ordering
  LIMIT ${limit}
  OFFSET ${offset}
`;

// 2. Result Parsing
const parsed = results.map(r => parseBlockQueryResult(r));

// 3. Return Typed Result
return { results: parsed, total, limit, offset };
```

### 3. Error Handling Pattern
Use consistent error handling throughout:

```typescript
// 1. Input Validation
if (!isValidPrincipal(address)) {
  throw new InvalidRequestError(
    `invalid STX address "${address}"`,
    InvalidRequestErrorType.invalid_address
  );
}

// 2. Resource Not Found
if (!block.found) {
  throw new NotFoundError('Block not found');
}

// 3. Database Errors are handled by Fastify error handler automatically
```

## CACHING ARCHITECTURE

### 1. ETag-Based HTTP Caching
Use ETags for efficient client-side caching:

```typescript
// Cache Strategy by Resource Type
enum ETagType {
  chainTip = 'chain_tip',           // Based on latest block
  mempool = 'mempool',              // Based on mempool digest
  transaction = 'transaction',       // Based on tx status
  block = 'block',                  // Based on block hash + canonical status
  principal = 'principal',          // Based on address balance changes
}
```

### 2. Cache Invalidation Strategy
- **Chain Tip Changes**: Invalidate all chain-dependent caches
- **New Blocks**: Invalidate block-specific and address-specific caches  
- **Mempool Changes**: Invalidate mempool-dependent caches
- **Reorgs**: Invalidate all caches (safety measure)

### 3. Cache Headers Pattern
```typescript
// Cache Control Headers
if (etag) {
  if (ifNoneMatch && typeof etag === 'string' && ifNoneMatch.includes(etag)) {
    await reply.header('Cache-Control', CACHE_CONTROL_MUST_REVALIDATE).code(304).send();
  } else if (typeof etag === 'string') {
    void reply.headers({ 
      'Cache-Control': CACHE_CONTROL_MUST_REVALIDATE, 
      ETag: `"${etag}"` 
    });
  }
}
```

## SECURITY ARCHITECTURE

### 1. Input Validation Layers
Multiple layers of validation:

```typescript
// Layer 1: Schema Validation (TypeBox)
schema: {
  params: Type.Object({
    address: AddressParamSchema,  // Regex validation
  }),
  querystring: Type.Object({
    limit: LimitParam(ResourceType.Block),
  }),
}

// Layer 2: Business Logic Validation
if (!isValidPrincipal(address)) {
  throw new InvalidRequestError(
    `invalid STX address "${address}"`,
    InvalidRequestErrorType.invalid_address
  );
}

// Layer 3: Database Parameter Binding (prevents SQL injection)
const results = await this.sql`
  SELECT * FROM addresses WHERE address = ${address}
`;
```

### 2. Rate Limiting Strategy
Implemented at infrastructure level with circuit breakers:

```typescript
// Rate limiting patterns
- Global rate limiting per IP
- Endpoint-specific rate limiting for expensive operations
- User-based rate limiting for authenticated endpoints
- Circuit breakers for external service calls
```

### 3. Data Sanitization
Ensure all blockchain data is properly validated:

```typescript
// Hex String Validation
function validateRequestHexInput(hash: string) {
  try {
    const buffer = hexToBuffer(hash);
    if (buffer.toString('hex') !== hash.substring(2).toLowerCase()) {
      throw new Error('Invalid hash characters');
    }
  } catch (error: any) {
    throw new InvalidRequestError(error.message, InvalidRequestErrorType.invalid_hash);
  }
}

// Principal Validation  
function validatePrincipal(stxAddress: string) {
  if (!isValidPrincipal(stxAddress)) {
    throw new InvalidRequestError(
      `invalid STX address "${stxAddress}"`,
      InvalidRequestErrorType.invalid_address
    );
  }
}
```

## PERFORMANCE ARCHITECTURE

### 1. Database Optimization
- **Indexes**: All frequently queried columns have appropriate indexes
- **Query Optimization**: Use EXPLAIN ANALYZE to verify query plans
- **Connection Pooling**: Managed by `postgres` client with appropriate pool sizes
- **Read Replicas**: Support for read-only database replicas

### 2. Pagination Strategy
Consistent pagination across all list endpoints:

```typescript
// Cursor-based Pagination for Large Datasets
interface PaginationParams {
  limit: number;          // Items per page
  offset?: number;        // Traditional offset
  cursor?: string;        // Cursor for large datasets
}

// Resource-Type Based Limits
enum ResourceType {
  Block,      // limit: 30,  default: 20
  Tx,         // limit: 50,  default: 20  
  Event,      // limit: 100, default: 20
}
```

### 3. Query Optimization Patterns
```typescript
// Use Column Constants
const results = await this.sql<BlockQueryResult[]>`
  SELECT ${this.sql(BLOCK_COLUMNS)}  // Pre-defined column list
  FROM blocks
  WHERE canonical = true
  ORDER BY block_height DESC
`;

// Efficient Joins with Prefixed Columns
const results = await this.sql`
  SELECT ${this.sql([
    'blocks.block_hash',
    'blocks.block_height',
    ...prefixedCols(TX_COLUMNS, 'txs'),
  ])}
  FROM blocks
  INNER JOIN txs ON blocks.block_hash = txs.block_hash
`;
```

## SCALABILITY ARCHITECTURE

### 1. Horizontal Scaling Patterns
- **Read-Only Mode**: API instances can run in read-only mode for scaling reads
- **Write-Only Mode**: Dedicated instances for processing blockchain events
- **Load Balancing**: Multiple API instances behind load balancer
- **Database Scaling**: Read replicas for query distribution

### 2. Microservice Boundaries
While currently monolithic, the architecture supports future microservice extraction:

```typescript
// Potential Service Boundaries
- Block Service: Block and microblock data
- Transaction Service: Transaction processing and queries  
- Address Service: Address balance and transaction history
- WebSocket Service: Real-time notifications
- Search Service: Cross-entity search functionality
```

### 3. Resource Management
```typescript
// Resource Type Classification
enum ResourceType {
  Block,           // Immutable after finalization
  Transaction,     // Immutable after confirmation  
  Mempool,        // Highly volatile
  Address,        // Changes with transactions
  Search,         // Computed on demand
}

// Different caching and scaling strategies per resource type
```

## MONITORING & OBSERVABILITY ARCHITECTURE

### 1. Metrics Collection
```typescript
// Prometheus Metrics
- API request rates and latencies by endpoint
- Database query performance and connection pool metrics
- Cache hit/miss ratios by cache type
- WebSocket connection counts and message rates
- Blockchain synchronization lag and event processing rates
```

### 2. Logging Strategy
```typescript
// Structured Logging with Pino
const logger = pino({
  level: 'info',
  formatters: {
    level: (label) => ({ level: label }),
  },
});

// Log Correlation
- Request ID tracking through all layers
- Transaction ID correlation for blockchain operations
- Error context preservation through the stack
```

### 3. Health Checking
```typescript
// Health Check Hierarchy
/extended/v1/status - API health with database connectivity
- Chain tip information
- Database connection status  
- Stacks node connectivity
- Last processed block information
```

## DEPLOYMENT ARCHITECTURE

### 1. Environment Management
```typescript
// Environment Configuration
- Development: Single instance with all components
- Staging: Production-like with reduced resources
- Production: High availability with redundancy
```

### 2. Database Migration Strategy
```typescript
// Migration Pattern
1. Schema changes in migrations/ directory
2. Backward-compatible changes preferred
3. Event replay capability for major schema changes
4. Rollback procedures for each migration
```

### 3. Rolling Deployment Pattern
```typescript
// Zero-Downtime Deployment
1. Deploy new instances in read-only mode
2. Verify health and functionality
3. Switch traffic to new instances
4. Gracefully shutdown old instances
5. Monitor for issues and rollback if needed
```

## ARCHITECTURAL DECISION RECORDS (ADRs)

### Documenting Architectural Decisions
All significant architectural decisions MUST be documented following this template:

```markdown
# ADR-001: [Decision Title]

## Status
[Proposed | Accepted | Deprecated | Superseded]

## Context
[What is the issue that we're seeing that is motivating this decision?]

## Decision
[What is the change that we're proposing or have agreed to?]

## Consequences
[What becomes easier or more difficult to do because of this change?]

## References
- [Related ADRs]
- [External references]
```

### Current Architectural Decisions
1. **ADR-001**: Use TypeBox for schema validation over other alternatives
2. **ADR-002**: Implement ETag-based caching for HTTP responses
3. **ADR-003**: Use `postgres` client over other database libraries
4. **ADR-004**: Separate V1 and V2 API versions with different routing

## ARCHITECTURE EVOLUTION GUIDELINES

### 1. Adding New Features
- Follow existing layering patterns
- Add appropriate tests at each layer
- Document any new architectural patterns
- Consider impact on existing caching strategy

### 2. Performance Optimization
- Measure before optimizing
- Consider caching strategy impact
- Maintain backward compatibility
- Document performance characteristics

### 3. Breaking Changes
- **Prohibited** in existing API versions
- Create new API version if necessary
- Provide migration path for consumers
- Deprecation warnings for old versions

### 4. External Dependencies
- Evaluate stability and maintenance
- Consider lock-in implications
- Have fallback/migration strategies
- Document integration patterns

Remember: **Architecture serves the business needs** of providing reliable, fast access to Stacks blockchain data. Every architectural decision should be evaluated against this primary goal while maintaining the ability to evolve safely over time.

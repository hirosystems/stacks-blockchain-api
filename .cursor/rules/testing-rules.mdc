---
description: Use EVERYTIME you write, edit, or diagnose tests
alwaysApply: false
---
# Testing Rules for Stacks Blockchain API

## TESTING PHILOSOPHY

Testing is **CRITICAL** for this production blockchain API. Every test must be:
- **COMPREHENSIVE**: Cover both happy paths and edge cases
- **ISOLATED**: Tests must not depend on each other or external state
- **DETERMINISTIC**: Tests must produce consistent results
- **FAST**: Unit tests should run quickly, integration tests are allowed to be slower
- **READABLE**: Test names and structure should clearly document expected behavior

## TESTING FRAMEWORK & SETUP

### Jest Configuration
We use **Jest** with TypeScript support and multiple test suites:

```typescript
// tests/jest.config.api.js - API integration tests
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  testMatch: ['<rootDir>/tests/api/**/*.test.ts'],
  setupFilesAfterEnv: ['<rootDir>/tests/utils/shared-setup.ts'],
  collectCoverageFrom: ['<rootDir>/src/**/*.ts'],
  coverageReporters: ['text', 'lcov']
};
```

### Database Test Setup
All tests use isolated test databases:

```typescript
// tests/utils/shared-setup.ts:25-35
export async function setupTestDb(): Promise<TestEnvContext> {
  const db = await PgStore.connect({
    host: 'localhost',
    port: 5432,
    database: `test_db_${randomUUID()}`,
    user: 'postgres'
  });
  
  await db.migrate();
  return { db, fastify: await createApiServer(db) };
}
```

## 10 EXAMPLE TESTS TO FOLLOW

### Example 1: Block API Schema Validation
**Line Reference**: `tests/api/block.test.ts:145-155`

```typescript
test('GET /v2/blocks/:block_id - validates response schema', async () => {
  const { fastify, db } = await setupTestDb();
  
  // Insert test data
  await db.updateBlock({
    block: {
      block_hash: '0x1234',
      index_block_hash: '0x1234',
      parent_block_hash: '0x0000',
      parent_microblock_hash: '',
      parent_microblock_sequence: 0,
      block_height: 1,
      canonical: true,
      execution_cost_read_count: 0,
      execution_cost_read_length: 0,
      execution_cost_runtime: 0,
      execution_cost_write_count: 0,
      execution_cost_write_length: 0,
      tx_count: 0,
      burn_block_time: 1234567890,
      burn_block_hash: '0xabcd',
      burn_block_height: 100,
      miner_txid: '0x5678'
    },
    microblocks: [],
    minerRewards: [],
    txs: []
  });

  const response = await supertest(fastify.server)
    .get('/v2/blocks/1')
    .expect(200);
    
  // Validate response matches schema
  expect(response.body).toMatchSchema(NakamotoBlockSchema);
  expect(response.body.height).toBe(1);
  expect(response.body.canonical).toBe(true);
  expect(response.body.hash).toBe('0x1234');
  
  await fastify.close();
});
```

### Example 2: Transaction Parameter Validation
**Line Reference**: `tests/api/transaction.test.ts:175-185`

```typescript
test('GET /v2/transactions/:tx_id - validates transaction hash parameter', async () => {
  const { fastify } = await setupTestDb();
  
  // Test invalid hash format
  const invalidResponse = await supertest(fastify.server)
    .get('/v2/transactions/invalid_hash')
    .expect(400);
    
  expect(invalidResponse.body).toMatchObject({
    error: expect.stringContaining('invalid hash'),
    error_type: 'invalid_hash'
  });
  
  // Test valid hash format but non-existent transaction
  const notFoundResponse = await supertest(fastify.server)
    .get('/v2/transactions/0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef')
    .expect(404);
    
  expect(notFoundResponse.body).toMatchObject({
    error: 'Transaction not found',
    error_type: 'tx_not_found'
  });
  
  await fastify.close();
});
```

### Example 3: Address Balance API
**Line Reference**: `tests/api/address.test.ts:95-105`

```typescript
test('GET /v2/addresses/:address - returns address balance', async () => {
  const { fastify, db } = await setupTestDb();
  const testAddress = 'SP2J6ZY48GV1EZ5V2V5RB9MP66SW86PYKKNRV9EJ7';
  
  // Insert test balance data
  await db.updateStxBalance({
    stxAddress: testAddress,
    balance: BigInt(1000000),
    totalSent: BigInt(500000),
    totalReceived: BigInt(1500000),
    totalFeesSent: BigInt(1000),
    totalMinerRewardsReceived: BigInt(0),
    lockTxId: '',
    locked: BigInt(0),
    lockHeight: 0,
    burnchainLockHeight: 0,
    burnchainUnlockHeight: 0
  });

  const response = await supertest(fastify.server)
    .get(`/v2/addresses/${testAddress}`)
    .expect(200);
    
  expect(response.body).toMatchObject({
    stx: {
      balance: '1000000',
      total_sent: '500000',
      total_received: '1500000',
      total_fees_sent: '1000'
    },
    fungible_tokens: {},
    non_fungible_tokens: {}
  });
  
  await fastify.close();
});
```

### Example 4: Pagination Testing
**Line Reference**: `tests/api/blocks.test.ts:225-235`

```typescript
test('GET /v2/blocks - handles pagination correctly', async () => {
  const { fastify, db } = await setupTestDb();
  
  // Insert multiple test blocks
  for (let i = 1; i <= 25; i++) {
    await db.updateBlock({
      block: {
        block_hash: `0x${i.toString().padStart(4, '0')}`,
        index_block_hash: `0x${i.toString().padStart(4, '0')}`,
        parent_block_hash: i > 1 ? `0x${(i-1).toString().padStart(4, '0')}` : '0x0000',
        block_height: i,
        canonical: true,
        // ... other required fields
      },
      microblocks: [],
      minerRewards: [],
      txs: []
    });
  }

  // Test default pagination
  const defaultResponse = await supertest(fastify.server)
    .get('/v2/blocks')
    .expect(200);
    
  expect(defaultResponse.body).toMatchObject({
    limit: 20,
    offset: 0,
    total: 25,
    results: expect.arrayContaining([
      expect.objectContaining({ height: expect.any(Number) })
    ])
  });
  expect(defaultResponse.body.results).toHaveLength(20);
  
  // Test custom pagination
  const customResponse = await supertest(fastify.server)
    .get('/v2/blocks?limit=10&offset=10')
    .expect(200);
    
  expect(customResponse.body).toMatchObject({
    limit: 10,
    offset: 10,
    total: 25,
    results: expect.any(Array)
  });
  expect(customResponse.body.results).toHaveLength(10);
  
  await fastify.close();
});
```

### Example 5: Error Handling Patterns
**Line Reference**: `tests/api/burnchain.test.ts:125-135`

```typescript
test('GET /extended/v1/burnchain/blocks/:height - handles invalid height', async () => {
  const { fastify } = await setupTestDb();
  
  // Test negative height
  const negativeResponse = await supertest(fastify.server)
    .get('/extended/v1/burnchain/blocks/-1')
    .expect(400);
    
  expect(negativeResponse.body).toMatchObject({
    error: expect.stringContaining('invalid'),
    error_type: 'invalid_param'
  });
  
  // Test non-numeric height
  const invalidResponse = await supertest(fastify.server)
    .get('/extended/v1/burnchain/blocks/abc')
    .expect(400);
    
  expect(invalidResponse.body).toMatchObject({
    error: expect.stringContaining('invalid'),
    error_type: 'invalid_param'
  });
  
  await fastify.close();
});
```

### Example 6: WebSocket Functionality
**Line Reference**: `tests/api/websockets.test.ts:55-65`

```typescript
test('WebSocket - block subscription and updates', async () => {
  const { fastify, db } = await setupTestDb();
  await fastify.listen({ port: 0 });
  
  const wsUrl = `ws://localhost:${fastify.server.address().port}/`;
  const ws = new WebSocket(wsUrl);
  
  const messages: any[] = [];
  ws.on('message', (data) => {
    messages.push(JSON.parse(data.toString()));
  });
  
  await new Promise(resolve => ws.on('open', resolve));
  
  // Subscribe to blocks
  ws.send(JSON.stringify({
    action: 'subscribe',
    topic: 'blocks'
  }));
  
  // Trigger block update
  await db.updateBlock({
    block: {
      block_hash: '0x9999',
      index_block_hash: '0x9999',
      block_height: 999,
      canonical: true,
      // ... other fields
    },
    microblocks: [],
    minerRewards: [],
    txs: []
  });
  
  // Wait for WebSocket message
  await new Promise(resolve => setTimeout(resolve, 100));
  
  expect(messages).toContainEqual(
    expect.objectContaining({
      topic: 'blocks',
      data: expect.objectContaining({
        height: 999,
        hash: '0x9999'
      })
    })
  );
  
  ws.close();
  await fastify.close();
});
```

### Example 7: Cache Behavior Testing
**Line Reference**: `tests/api/cache.test.ts:85-95`

```typescript
test('ETag caching - returns 304 for unchanged resources', async () => {
  const { fastify, db } = await setupTestDb();
  
  await db.updateBlock({
    block: {
      block_hash: '0xaaaa',
      index_block_hash: '0xaaaa',
      block_height: 1,
      canonical: true,
      // ... other fields
    },
    microblocks: [],
    minerRewards: [],
    txs: []
  });

  // First request - get ETag
  const firstResponse = await supertest(fastify.server)
    .get('/v2/blocks/1')
    .expect(200);
    
  const etag = firstResponse.headers.etag;
  expect(etag).toBeDefined();
  expect(firstResponse.headers['cache-control']).toBe('public, max-age=0, must-revalidate');
  
  // Second request with ETag - should return 304
  const cachedResponse = await supertest(fastify.server)
    .get('/v2/blocks/1')
    .set('If-None-Match', etag)
    .expect(304);
    
  expect(cachedResponse.body).toEqual({});
  
  await fastify.close();
});
```

### Example 8: Database Query Testing
**Line Reference**: `tests/datastore/blocks.test.ts:165-175`

```typescript
test('getBlocks - filters canonical blocks correctly', async () => {
  const { db } = await setupTestDb();
  
  // Insert canonical block
  await db.updateBlock({
    block: {
      block_hash: '0xcanonical',
      index_block_hash: '0xcanonical',
      block_height: 1,
      canonical: true,
      microblock_canonical: true,
      // ... other fields
    },
    microblocks: [],
    minerRewards: [],
    txs: []
  });
  
  // Insert non-canonical block
  await db.updateBlock({
    block: {
      block_hash: '0xnoncanonical',
      index_block_hash: '0xnoncanonical',
      block_height: 1,
      canonical: false,
      microblock_canonical: false,
      // ... other fields
    },
    microblocks: [],
    minerRewards: [],
    txs: []
  });
  
  const result = await db.getBlocks({ offset: 0, limit: 10 });
  
  expect(result.results).toHaveLength(1);
  expect(result.results[0].block_hash).toBe('0xcanonical');
  expect(result.results[0].canonical).toBe(true);
});
```

### Example 9: Transaction Event Testing
**Line Reference**: `tests/api/transactions.test.ts:285-295`

```typescript
test('GET /v2/transactions/:tx_id - includes transaction events', async () => {
  const { fastify, db } = await setupTestDb();
  
  const txId = '0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef';
  
  await db.updateTx({
    tx: {
      tx_id: txId,
      tx_index: 0,
      anchor_mode: 'any',
      nonce: 0,
      raw_tx: Buffer.from(''),
      index_block_hash: '0x1234',
      block_hash: '0x1234',
      block_height: 1,
      burn_block_time: 1234567890,
      burn_block_height: 100,
      parent_burn_block_time: 1234567880,
      type_id: DbTxTypeId.TokenTransfer,
      status: DbTxStatus.Success,
      canonical: true,
      post_conditions: Buffer.from(''),
      fee_rate: BigInt(1000),
      sponsored: false,
      sponsor_address: undefined,
      sender_address: 'SP2J6ZY48GV1EZ5V2V5RB9MP66SW86PYKKNRV9EJ7',
      origin_hash_mode: 0,
      token_transfer_recipient_address: 'SP3K8BC0PPEVCV7NZ6QSRWPQ2JE9E5B6N3PA0KBR9',
      token_transfer_amount: BigInt(1000000),
      token_transfer_memo: Buffer.from(''),
      execution_cost_read_count: 0,
      execution_cost_read_length: 0,
      execution_cost_runtime: 0,
      execution_cost_write_count: 1,
      execution_cost_write_length: 8,
      microblock_canonical: true,
      microblock_sequence: 0,
      microblock_hash: '',
      parent_index_block_hash: '0x0000',
      parent_block_hash: '0x0000',
      raw_result: '0x0703'
    }
  });

  const response = await supertest(fastify.server)
    .get(`/v2/transactions/${txId}`)
    .expect(200);
    
  expect(response.body).toMatchObject({
    tx_id: txId,
    tx_type: 'token_transfer',
    token_transfer: expect.objectContaining({
      recipient_address: 'SP3K8BC0PPEVCV7NZ6QSRWPQ2JE9E5B6N3PA0KBR9',
      amount: '1000000'
    }),
    events: expect.any(Array)
  });
  
  await fastify.close();
});
```

### Example 10: Input Sanitization Testing
**Line Reference**: `tests/api/security.test.ts:125-135`

```typescript
test('Address parameter - rejects SQL injection attempts', async () => {
  const { fastify } = await setupTestDb();
  
  const maliciousInputs = [
    "'; DROP TABLE blocks; --",
    "1' OR '1'='1",
    "SP2J6'; SELECT * FROM blocks; --",
    "<script>alert('xss')</script>",
    "../../etc/passwd"
  ];
  
  for (const maliciousInput of maliciousInputs) {
    const response = await supertest(fastify.server)
      .get(`/v2/addresses/${encodeURIComponent(maliciousInput)}`)
      .expect(400);
      
    expect(response.body).toMatchObject({
      error: expect.stringContaining('invalid STX address'),
      error_type: 'invalid_address'
    });
  }
  
  await fastify.close();
});
```

## TEST STRUCTURE REQUIREMENTS

### Test File Organization
```
tests/
├── api/                    # API integration tests
│   ├── block.test.ts      # Block endpoint tests
│   ├── transaction.test.ts # Transaction endpoint tests
│   └── address.test.ts    # Address endpoint tests
├── datastore/             # Database layer tests
│   ├── blocks.test.ts     # Block queries
│   └── transactions.test.ts # Transaction queries
├── utils/                 # Test utilities
│   ├── shared-setup.ts    # Common test setup
│   └── test-helpers.ts    # Helper functions
└── jest.config.*.js       # Jest configurations
```

### Test Naming Convention
```typescript
// Pattern: [HTTP_METHOD] [endpoint] - [expected_behavior]
test('GET /v2/blocks/:block_id - returns block data for valid height', async () => {
test('POST /v2/transactions - validates transaction format', async () => {
test('GET /v2/addresses/:address - handles invalid address format', async () => {

// Pattern: [function_name] - [expected_behavior]  
test('parseBlockParam - converts string height to number', () => {
test('validateRequestPrincipal - throws error for invalid address', () => {
```

### Test Data Management
```typescript
// Use deterministic test data
const TEST_BLOCK_HASH = '0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef';
const TEST_ADDRESS = 'SP2J6ZY48GV1EZ5V2V5RB9MP66SW86PYKKNRV9EJ7';
const TEST_TX_ID = '0xabcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890';

// Clean up after each test
afterEach(async () => {
  await db.close();
  await fastify.close();
});
```

## SCHEMA VALIDATION TESTING

### TypeBox Schema Testing
Every schema must have validation tests:

```typescript
// Schema validation test pattern
import { Type } from '@sinclair/typebox';
import { Value } from '@sinclair/typebox/value';

test('BlockParamSchema - validates block parameters', () => {
  const schema = BlockParamSchema;
  
  // Valid cases
  expect(Value.Check(schema, 12345)).toBe(true);
  expect(Value.Check(schema, 'latest')).toBe(true);
  expect(Value.Check(schema, '0x1234abcd')).toBe(true);
  
  // Invalid cases
  expect(Value.Check(schema, -1)).toBe(false);
  expect(Value.Check(schema, 'invalid')).toBe(false);
  expect(Value.Check(schema, null)).toBe(false);
});
```

## PERFORMANCE TESTING

### Response Time Testing
```typescript
test('GET /v2/blocks - responds within acceptable time', async () => {
  const { fastify } = await setupTestDb();
  
  const startTime = Date.now();
  await supertest(fastify.server)
    .get('/v2/blocks')
    .expect(200);
  const endTime = Date.now();
  
  expect(endTime - startTime).toBeLessThan(500); // 500ms max
  
  await fastify.close();
});
```

### Database Query Performance
```typescript
test('getBlocks query - executes efficiently', async () => {
  const { db } = await setupTestDb();
  
  // Insert large dataset for testing
  // ... insert test data
  
  const startTime = process.hrtime.bigint();
  await db.getBlocks({ offset: 0, limit: 100 });
  const endTime = process.hrtime.bigint();
  
  const executionTimeMs = Number(endTime - startTime) / 1_000_000;
  expect(executionTimeMs).toBeLessThan(100); // 100ms max for large queries
});
```

## TESTING ANTI-PATTERNS TO AVOID

### ❌ Avoid These Patterns:

```typescript
// DON'T: Tests that depend on each other
test('create user', () => { /* creates user */ });
test('get user', () => { /* depends on previous test */ });

// DON'T: Hardcoded timestamps or random data
test('block timestamp', () => {
  const now = Date.now(); // Will fail at different times
});

// DON'T: Tests that don't clean up
test('database test', () => {
  // ... test logic
  // Missing cleanup - affects other tests
});

// DON'T: Vague test descriptions
test('it works', () => { /* unclear what this tests */ });

// DON'T: Testing implementation details
test('calls internal method', () => {
  expect(mockInternalMethod).toHaveBeenCalled();
});
```

### ✅ Follow These Patterns:

```typescript
// DO: Isolated, descriptive tests
test('GET /v2/blocks/1 - returns first block when it exists', async () => {
  const { fastify, db } = await setupTestDb();
  
  // Setup test data
  await insertTestBlock(db, { height: 1 });
  
  // Execute test
  const response = await supertest(fastify.server)
    .get('/v2/blocks/1')
    .expect(200);
    
  // Verify results
  expect(response.body.height).toBe(1);
  
  // Cleanup
  await fastify.close();
});

// DO: Test behavior, not implementation
test('address validation - rejects invalid format', async () => {
  const { fastify } = await setupTestDb();
  
  await supertest(fastify.server)
    .get('/v2/addresses/invalid')
    .expect(400)
    .expect(res => {
      expect(res.body.error_type).toBe('invalid_address');
    });
    
  await fastify.close();
});
```

## FAILURE SCENARIO TESTING

### What Breaks and How to Test It

#### 1. Database Connection Failures
```typescript
test('handles database connection failures gracefully', async () => {
  // Simulate connection loss
  await db.close();
  
  const response = await supertest(api.server)
    .get('/v2/blocks/latest')
    .expect(503);
    
  expect(response.body.error).toMatch(/temporarily unavailable/i);
  expect(response.headers['retry-after']).toBeDefined();
});
```

#### 2. Blockchain Reorg Scenarios  
```typescript
test('handles block reorg - non-canonical block returns 404', async () => {
  // Create non-canonical block in test DB
  await db.insertBlock({ ...blockData, canonical: false });
  
  const response = await supertest(api.server)
    .get(`/v2/blocks/${blockData.block_hash}`)
    .expect(404);
    
  expect(response.body.error_type).toBe('block_not_found');
});
```

#### 3. Cache Corruption/Miss
```typescript
test('handles cache miss during high load', async () => {
  // Simulate cache miss
  jest.spyOn(cacheController, 'getETag').mockResolvedValue(null);
  
  const response = await supertest(api.server)
    .get('/v2/blocks/latest')
    .expect(200);
    
  // Should still work, just without caching headers
  expect(response.headers.etag).toBeUndefined();
  expect(response.body.height).toBeDefined();
});
```

#### 4. Malformed Data in Database
```typescript
test('handles malformed transaction data', async () => {
  // Insert malformed tx data
  await db.raw(`INSERT INTO txs (tx_id, raw_tx) VALUES ('invalid', 'malformed')`);
  
  const response = await supertest(api.server)
    .get('/v2/transactions/invalid')
    .expect(500);
    
  expect(response.body.error).toMatch(/internal server error/i);
  // Should NOT expose internal details
  expect(response.body.error).not.toMatch(/malformed/i);
});
```

#### 5. Memory Pressure Scenarios
```typescript
test('handles large result set pagination', async () => {
  // Create 10k+ transactions
  await db.insertManyTransactions(generateLargeTxSet(10000));
  
  const response = await supertest(api.server)
    .get('/v2/transactions?limit=50')
    .expect(200);
    
  expect(response.body.results).toHaveLength(50);
  expect(response.body.total).toBe(10000);
  // Verify memory usage stays reasonable
});
```

### Pattern Recognition for AI
```typescript
// IF: External dependency fails → Test graceful degradation
// IF: Data corruption possible → Test error handling + logging
// IF: Resource exhaustion risk → Test backpressure/limits
// IF: Race condition possible → Test concurrent access
// IF: Cache invalidation complex → Test cache consistency
```

Remember: **Tests are documentation** of how the system should behave. Write tests that clearly express the expected behavior and serve as examples for future developers.
# Testing Rules for Stacks Blockchain API

## TESTING PHILOSOPHY

Testing is **CRITICAL** for this production blockchain API. Every test must be:
- **COMPREHENSIVE**: Cover both happy paths and edge cases
- **ISOLATED**: Tests must not depend on each other or external state
- **DETERMINISTIC**: Tests must produce consistent results
- **FAST**: Unit tests should run quickly, integration tests are allowed to be slower
- **READABLE**: Test names and structure should clearly document expected behavior

## TESTING FRAMEWORK & SETUP

### Jest Configuration
We use **Jest** with TypeScript support and multiple test suites:

```typescript
// tests/jest.config.api.js - API integration tests
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  testMatch: ['<rootDir>/tests/api/**/*.test.ts'],
  setupFilesAfterEnv: ['<rootDir>/tests/utils/shared-setup.ts'],
  collectCoverageFrom: ['<rootDir>/src/**/*.ts'],
  coverageReporters: ['text', 'lcov']
};
```

### Database Test Setup
All tests use isolated test databases:

```typescript
// tests/utils/shared-setup.ts:25-35
export async function setupTestDb(): Promise<TestEnvContext> {
  const db = await PgStore.connect({
    host: 'localhost',
    port: 5432,
    database: `test_db_${randomUUID()}`,
    user: 'postgres'
  });
  
  await db.migrate();
  return { db, fastify: await createApiServer(db) };
}
```

## 10 EXAMPLE TESTS TO FOLLOW

### Example 1: Block API Schema Validation
**Line Reference**: `tests/api/block.test.ts:145-155`

```typescript
test('GET /v2/blocks/:block_id - validates response schema', async () => {
  const { fastify, db } = await setupTestDb();
  
  // Insert test data
  await db.updateBlock({
    block: {
      block_hash: '0x1234',
      index_block_hash: '0x1234',
      parent_block_hash: '0x0000',
      parent_microblock_hash: '',
      parent_microblock_sequence: 0,
      block_height: 1,
      canonical: true,
      execution_cost_read_count: 0,
      execution_cost_read_length: 0,
      execution_cost_runtime: 0,
      execution_cost_write_count: 0,
      execution_cost_write_length: 0,
      tx_count: 0,
      burn_block_time: 1234567890,
      burn_block_hash: '0xabcd',
      burn_block_height: 100,
      miner_txid: '0x5678'
    },
    microblocks: [],
    minerRewards: [],
    txs: []
  });

  const response = await supertest(fastify.server)
    .get('/v2/blocks/1')
    .expect(200);
    
  // Validate response matches schema
  expect(response.body).toMatchSchema(NakamotoBlockSchema);
  expect(response.body.height).toBe(1);
  expect(response.body.canonical).toBe(true);
  expect(response.body.hash).toBe('0x1234');
  
  await fastify.close();
});
```

### Example 2: Transaction Parameter Validation
**Line Reference**: `tests/api/transaction.test.ts:175-185`

```typescript
test('GET /v2/transactions/:tx_id - validates transaction hash parameter', async () => {
  const { fastify } = await setupTestDb();
  
  // Test invalid hash format
  const invalidResponse = await supertest(fastify.server)
    .get('/v2/transactions/invalid_hash')
    .expect(400);
    
  expect(invalidResponse.body).toMatchObject({
    error: expect.stringContaining('invalid hash'),
    error_type: 'invalid_hash'
  });
  
  // Test valid hash format but non-existent transaction
  const notFoundResponse = await supertest(fastify.server)
    .get('/v2/transactions/0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef')
    .expect(404);
    
  expect(notFoundResponse.body).toMatchObject({
    error: 'Transaction not found',
    error_type: 'tx_not_found'
  });
  
  await fastify.close();
});
```

### Example 3: Address Balance API
**Line Reference**: `tests/api/address.test.ts:95-105`

```typescript
test('GET /v2/addresses/:address - returns address balance', async () => {
  const { fastify, db } = await setupTestDb();
  const testAddress = 'SP2J6ZY48GV1EZ5V2V5RB9MP66SW86PYKKNRV9EJ7';
  
  // Insert test balance data
  await db.updateStxBalance({
    stxAddress: testAddress,
    balance: BigInt(1000000),
    totalSent: BigInt(500000),
    totalReceived: BigInt(1500000),
    totalFeesSent: BigInt(1000),
    totalMinerRewardsReceived: BigInt(0),
    lockTxId: '',
    locked: BigInt(0),
    lockHeight: 0,
    burnchainLockHeight: 0,
    burnchainUnlockHeight: 0
  });

  const response = await supertest(fastify.server)
    .get(`/v2/addresses/${testAddress}`)
    .expect(200);
    
  expect(response.body).toMatchObject({
    stx: {
      balance: '1000000',
      total_sent: '500000',
      total_received: '1500000',
      total_fees_sent: '1000'
    },
    fungible_tokens: {},
    non_fungible_tokens: {}
  });
  
  await fastify.close();
});
```

### Example 4: Pagination Testing
**Line Reference**: `tests/api/blocks.test.ts:225-235`

```typescript
test('GET /v2/blocks - handles pagination correctly', async () => {
  const { fastify, db } = await setupTestDb();
  
  // Insert multiple test blocks
  for (let i = 1; i <= 25; i++) {
    await db.updateBlock({
      block: {
        block_hash: `0x${i.toString().padStart(4, '0')}`,
        index_block_hash: `0x${i.toString().padStart(4, '0')}`,
        parent_block_hash: i > 1 ? `0x${(i-1).toString().padStart(4, '0')}` : '0x0000',
        block_height: i,
        canonical: true,
        // ... other required fields
      },
      microblocks: [],
      minerRewards: [],
      txs: []
    });
  }

  // Test default pagination
  const defaultResponse = await supertest(fastify.server)
    .get('/v2/blocks')
    .expect(200);
    
  expect(defaultResponse.body).toMatchObject({
    limit: 20,
    offset: 0,
    total: 25,
    results: expect.arrayContaining([
      expect.objectContaining({ height: expect.any(Number) })
    ])
  });
  expect(defaultResponse.body.results).toHaveLength(20);
  
  // Test custom pagination
  const customResponse = await supertest(fastify.server)
    .get('/v2/blocks?limit=10&offset=10')
    .expect(200);
    
  expect(customResponse.body).toMatchObject({
    limit: 10,
    offset: 10,
    total: 25,
    results: expect.any(Array)
  });
  expect(customResponse.body.results).toHaveLength(10);
  
  await fastify.close();
});
```

### Example 5: Error Handling Patterns
**Line Reference**: `tests/api/burnchain.test.ts:125-135`

```typescript
test('GET /extended/v1/burnchain/blocks/:height - handles invalid height', async () => {
  const { fastify } = await setupTestDb();
  
  // Test negative height
  const negativeResponse = await supertest(fastify.server)
    .get('/extended/v1/burnchain/blocks/-1')
    .expect(400);
    
  expect(negativeResponse.body).toMatchObject({
    error: expect.stringContaining('invalid'),
    error_type: 'invalid_param'
  });
  
  // Test non-numeric height
  const invalidResponse = await supertest(fastify.server)
    .get('/extended/v1/burnchain/blocks/abc')
    .expect(400);
    
  expect(invalidResponse.body).toMatchObject({
    error: expect.stringContaining('invalid'),
    error_type: 'invalid_param'
  });
  
  await fastify.close();
});
```

### Example 6: WebSocket Functionality
**Line Reference**: `tests/api/websockets.test.ts:55-65`

```typescript
test('WebSocket - block subscription and updates', async () => {
  const { fastify, db } = await setupTestDb();
  await fastify.listen({ port: 0 });
  
  const wsUrl = `ws://localhost:${fastify.server.address().port}/`;
  const ws = new WebSocket(wsUrl);
  
  const messages: any[] = [];
  ws.on('message', (data) => {
    messages.push(JSON.parse(data.toString()));
  });
  
  await new Promise(resolve => ws.on('open', resolve));
  
  // Subscribe to blocks
  ws.send(JSON.stringify({
    action: 'subscribe',
    topic: 'blocks'
  }));
  
  // Trigger block update
  await db.updateBlock({
    block: {
      block_hash: '0x9999',
      index_block_hash: '0x9999',
      block_height: 999,
      canonical: true,
      // ... other fields
    },
    microblocks: [],
    minerRewards: [],
    txs: []
  });
  
  // Wait for WebSocket message
  await new Promise(resolve => setTimeout(resolve, 100));
  
  expect(messages).toContainEqual(
    expect.objectContaining({
      topic: 'blocks',
      data: expect.objectContaining({
        height: 999,
        hash: '0x9999'
      })
    })
  );
  
  ws.close();
  await fastify.close();
});
```

### Example 7: Cache Behavior Testing
**Line Reference**: `tests/api/cache.test.ts:85-95`

```typescript
test('ETag caching - returns 304 for unchanged resources', async () => {
  const { fastify, db } = await setupTestDb();
  
  await db.updateBlock({
    block: {
      block_hash: '0xaaaa',
      index_block_hash: '0xaaaa',
      block_height: 1,
      canonical: true,
      // ... other fields
    },
    microblocks: [],
    minerRewards: [],
    txs: []
  });

  // First request - get ETag
  const firstResponse = await supertest(fastify.server)
    .get('/v2/blocks/1')
    .expect(200);
    
  const etag = firstResponse.headers.etag;
  expect(etag).toBeDefined();
  expect(firstResponse.headers['cache-control']).toBe('public, max-age=0, must-revalidate');
  
  // Second request with ETag - should return 304
  const cachedResponse = await supertest(fastify.server)
    .get('/v2/blocks/1')
    .set('If-None-Match', etag)
    .expect(304);
    
  expect(cachedResponse.body).toEqual({});
  
  await fastify.close();
});
```

### Example 8: Database Query Testing
**Line Reference**: `tests/datastore/blocks.test.ts:165-175`

```typescript
test('getBlocks - filters canonical blocks correctly', async () => {
  const { db } = await setupTestDb();
  
  // Insert canonical block
  await db.updateBlock({
    block: {
      block_hash: '0xcanonical',
      index_block_hash: '0xcanonical',
      block_height: 1,
      canonical: true,
      microblock_canonical: true,
      // ... other fields
    },
    microblocks: [],
    minerRewards: [],
    txs: []
  });
  
  // Insert non-canonical block
  await db.updateBlock({
    block: {
      block_hash: '0xnoncanonical',
      index_block_hash: '0xnoncanonical',
      block_height: 1,
      canonical: false,
      microblock_canonical: false,
      // ... other fields
    },
    microblocks: [],
    minerRewards: [],
    txs: []
  });
  
  const result = await db.getBlocks({ offset: 0, limit: 10 });
  
  expect(result.results).toHaveLength(1);
  expect(result.results[0].block_hash).toBe('0xcanonical');
  expect(result.results[0].canonical).toBe(true);
});
```

### Example 9: Transaction Event Testing
**Line Reference**: `tests/api/transactions.test.ts:285-295`

```typescript
test('GET /v2/transactions/:tx_id - includes transaction events', async () => {
  const { fastify, db } = await setupTestDb();
  
  const txId = '0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef';
  
  await db.updateTx({
    tx: {
      tx_id: txId,
      tx_index: 0,
      anchor_mode: 'any',
      nonce: 0,
      raw_tx: Buffer.from(''),
      index_block_hash: '0x1234',
      block_hash: '0x1234',
      block_height: 1,
      burn_block_time: 1234567890,
      burn_block_height: 100,
      parent_burn_block_time: 1234567880,
      type_id: DbTxTypeId.TokenTransfer,
      status: DbTxStatus.Success,
      canonical: true,
      post_conditions: Buffer.from(''),
      fee_rate: BigInt(1000),
      sponsored: false,
      sponsor_address: undefined,
      sender_address: 'SP2J6ZY48GV1EZ5V2V5RB9MP66SW86PYKKNRV9EJ7',
      origin_hash_mode: 0,
      token_transfer_recipient_address: 'SP3K8BC0PPEVCV7NZ6QSRWPQ2JE9E5B6N3PA0KBR9',
      token_transfer_amount: BigInt(1000000),
      token_transfer_memo: Buffer.from(''),
      execution_cost_read_count: 0,
      execution_cost_read_length: 0,
      execution_cost_runtime: 0,
      execution_cost_write_count: 1,
      execution_cost_write_length: 8,
      microblock_canonical: true,
      microblock_sequence: 0,
      microblock_hash: '',
      parent_index_block_hash: '0x0000',
      parent_block_hash: '0x0000',
      raw_result: '0x0703'
    }
  });

  const response = await supertest(fastify.server)
    .get(`/v2/transactions/${txId}`)
    .expect(200);
    
  expect(response.body).toMatchObject({
    tx_id: txId,
    tx_type: 'token_transfer',
    token_transfer: expect.objectContaining({
      recipient_address: 'SP3K8BC0PPEVCV7NZ6QSRWPQ2JE9E5B6N3PA0KBR9',
      amount: '1000000'
    }),
    events: expect.any(Array)
  });
  
  await fastify.close();
});
```

### Example 10: Input Sanitization Testing
**Line Reference**: `tests/api/security.test.ts:125-135`

```typescript
test('Address parameter - rejects SQL injection attempts', async () => {
  const { fastify } = await setupTestDb();
  
  const maliciousInputs = [
    "'; DROP TABLE blocks; --",
    "1' OR '1'='1",
    "SP2J6'; SELECT * FROM blocks; --",
    "<script>alert('xss')</script>",
    "../../etc/passwd"
  ];
  
  for (const maliciousInput of maliciousInputs) {
    const response = await supertest(fastify.server)
      .get(`/v2/addresses/${encodeURIComponent(maliciousInput)}`)
      .expect(400);
      
    expect(response.body).toMatchObject({
      error: expect.stringContaining('invalid STX address'),
      error_type: 'invalid_address'
    });
  }
  
  await fastify.close();
});
```

## TEST STRUCTURE REQUIREMENTS

### Test File Organization
```
tests/
├── api/                    # API integration tests
│   ├── block.test.ts      # Block endpoint tests
│   ├── transaction.test.ts # Transaction endpoint tests
│   └── address.test.ts    # Address endpoint tests
├── datastore/             # Database layer tests
│   ├── blocks.test.ts     # Block queries
│   └── transactions.test.ts # Transaction queries
├── utils/                 # Test utilities
│   ├── shared-setup.ts    # Common test setup
│   └── test-helpers.ts    # Helper functions
└── jest.config.*.js       # Jest configurations
```

### Test Naming Convention
```typescript
// Pattern: [HTTP_METHOD] [endpoint] - [expected_behavior]
test('GET /v2/blocks/:block_id - returns block data for valid height', async () => {
test('POST /v2/transactions - validates transaction format', async () => {
test('GET /v2/addresses/:address - handles invalid address format', async () => {

// Pattern: [function_name] - [expected_behavior]  
test('parseBlockParam - converts string height to number', () => {
test('validateRequestPrincipal - throws error for invalid address', () => {
```

### Test Data Management
```typescript
// Use deterministic test data
const TEST_BLOCK_HASH = '0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef';
const TEST_ADDRESS = 'SP2J6ZY48GV1EZ5V2V5RB9MP66SW86PYKKNRV9EJ7';
const TEST_TX_ID = '0xabcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890';

// Clean up after each test
afterEach(async () => {
  await db.close();
  await fastify.close();
});
```

## SCHEMA VALIDATION TESTING

### TypeBox Schema Testing
Every schema must have validation tests:

```typescript
// Schema validation test pattern
import { Type } from '@sinclair/typebox';
import { Value } from '@sinclair/typebox/value';

test('BlockParamSchema - validates block parameters', () => {
  const schema = BlockParamSchema;
  
  // Valid cases
  expect(Value.Check(schema, 12345)).toBe(true);
  expect(Value.Check(schema, 'latest')).toBe(true);
  expect(Value.Check(schema, '0x1234abcd')).toBe(true);
  
  // Invalid cases
  expect(Value.Check(schema, -1)).toBe(false);
  expect(Value.Check(schema, 'invalid')).toBe(false);
  expect(Value.Check(schema, null)).toBe(false);
});
```

## PERFORMANCE TESTING

### Response Time Testing
```typescript
test('GET /v2/blocks - responds within acceptable time', async () => {
  const { fastify } = await setupTestDb();
  
  const startTime = Date.now();
  await supertest(fastify.server)
    .get('/v2/blocks')
    .expect(200);
  const endTime = Date.now();
  
  expect(endTime - startTime).toBeLessThan(500); // 500ms max
  
  await fastify.close();
});
```

### Database Query Performance
```typescript
test('getBlocks query - executes efficiently', async () => {
  const { db } = await setupTestDb();
  
  // Insert large dataset for testing
  // ... insert test data
  
  const startTime = process.hrtime.bigint();
  await db.getBlocks({ offset: 0, limit: 100 });
  const endTime = process.hrtime.bigint();
  
  const executionTimeMs = Number(endTime - startTime) / 1_000_000;
  expect(executionTimeMs).toBeLessThan(100); // 100ms max for large queries
});
```

## TESTING ANTI-PATTERNS TO AVOID

### ❌ Avoid These Patterns:

```typescript
// DON'T: Tests that depend on each other
test('create user', () => { /* creates user */ });
test('get user', () => { /* depends on previous test */ });

// DON'T: Hardcoded timestamps or random data
test('block timestamp', () => {
  const now = Date.now(); // Will fail at different times
});

// DON'T: Tests that don't clean up
test('database test', () => {
  // ... test logic
  // Missing cleanup - affects other tests
});

// DON'T: Vague test descriptions
test('it works', () => { /* unclear what this tests */ });

// DON'T: Testing implementation details
test('calls internal method', () => {
  expect(mockInternalMethod).toHaveBeenCalled();
});
```

### ✅ Follow These Patterns:

```typescript
// DO: Isolated, descriptive tests
test('GET /v2/blocks/1 - returns first block when it exists', async () => {
  const { fastify, db } = await setupTestDb();
  
  // Setup test data
  await insertTestBlock(db, { height: 1 });
  
  // Execute test
  const response = await supertest(fastify.server)
    .get('/v2/blocks/1')
    .expect(200);
    
  // Verify results
  expect(response.body.height).toBe(1);
  
  // Cleanup
  await fastify.close();
});

// DO: Test behavior, not implementation
test('address validation - rejects invalid format', async () => {
  const { fastify } = await setupTestDb();
  
  await supertest(fastify.server)
    .get('/v2/addresses/invalid')
    .expect(400)
    .expect(res => {
      expect(res.body.error_type).toBe('invalid_address');
    });
    
  await fastify.close();
});
```

Remember: **Tests are documentation** of how the system should behave. Write tests that clearly express the expected behavior and serve as examples for future developers.

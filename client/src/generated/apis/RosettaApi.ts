/* tslint:disable */
/* eslint-disable */
/**
 * Stacks Blockchain API
 * Welcome to the API reference overview for the <a href=\"https://docs.hiro.so/get-started/stacks-blockchain-api\">Stacks Blockchain API</a>.  <a href=\"https://hirosystems.github.io/stacks-blockchain-api/collection.json\" download=\"stacks-api-collection.json\">Download Postman collection</a> 
 *
 * The version of the OpenAPI document: STACKS_API_VERSION
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    RosettaAccountBalanceRequest,
    RosettaAccountBalanceRequestFromJSON,
    RosettaAccountBalanceRequestToJSON,
    RosettaAccountBalanceResponse,
    RosettaAccountBalanceResponseFromJSON,
    RosettaAccountBalanceResponseToJSON,
    RosettaBlockRequest,
    RosettaBlockRequestFromJSON,
    RosettaBlockRequestToJSON,
    RosettaBlockResponse,
    RosettaBlockResponseFromJSON,
    RosettaBlockResponseToJSON,
    RosettaBlockTransactionRequest,
    RosettaBlockTransactionRequestFromJSON,
    RosettaBlockTransactionRequestToJSON,
    RosettaBlockTransactionResponse,
    RosettaBlockTransactionResponseFromJSON,
    RosettaBlockTransactionResponseToJSON,
    RosettaConstructionCombineRequest,
    RosettaConstructionCombineRequestFromJSON,
    RosettaConstructionCombineRequestToJSON,
    RosettaConstructionCombineResponse,
    RosettaConstructionCombineResponseFromJSON,
    RosettaConstructionCombineResponseToJSON,
    RosettaConstructionDeriveRequest,
    RosettaConstructionDeriveRequestFromJSON,
    RosettaConstructionDeriveRequestToJSON,
    RosettaConstructionDeriveResponse,
    RosettaConstructionDeriveResponseFromJSON,
    RosettaConstructionDeriveResponseToJSON,
    RosettaConstructionHashRequest,
    RosettaConstructionHashRequestFromJSON,
    RosettaConstructionHashRequestToJSON,
    RosettaConstructionHashResponse,
    RosettaConstructionHashResponseFromJSON,
    RosettaConstructionHashResponseToJSON,
    RosettaConstructionMetadataRequest,
    RosettaConstructionMetadataRequestFromJSON,
    RosettaConstructionMetadataRequestToJSON,
    RosettaConstructionMetadataResponse,
    RosettaConstructionMetadataResponseFromJSON,
    RosettaConstructionMetadataResponseToJSON,
    RosettaConstructionParseRequest,
    RosettaConstructionParseRequestFromJSON,
    RosettaConstructionParseRequestToJSON,
    RosettaConstructionParseResponse,
    RosettaConstructionParseResponseFromJSON,
    RosettaConstructionParseResponseToJSON,
    RosettaConstructionPayloadResponse,
    RosettaConstructionPayloadResponseFromJSON,
    RosettaConstructionPayloadResponseToJSON,
    RosettaConstructionPayloadsRequest,
    RosettaConstructionPayloadsRequestFromJSON,
    RosettaConstructionPayloadsRequestToJSON,
    RosettaConstructionPreprocessRequest,
    RosettaConstructionPreprocessRequestFromJSON,
    RosettaConstructionPreprocessRequestToJSON,
    RosettaConstructionPreprocessResponse,
    RosettaConstructionPreprocessResponseFromJSON,
    RosettaConstructionPreprocessResponseToJSON,
    RosettaConstructionSubmitRequest,
    RosettaConstructionSubmitRequestFromJSON,
    RosettaConstructionSubmitRequestToJSON,
    RosettaConstructionSubmitResponse,
    RosettaConstructionSubmitResponseFromJSON,
    RosettaConstructionSubmitResponseToJSON,
    RosettaError,
    RosettaErrorFromJSON,
    RosettaErrorToJSON,
    RosettaMempoolRequest,
    RosettaMempoolRequestFromJSON,
    RosettaMempoolRequestToJSON,
    RosettaMempoolResponse,
    RosettaMempoolResponseFromJSON,
    RosettaMempoolResponseToJSON,
    RosettaMempoolTransactionRequest,
    RosettaMempoolTransactionRequestFromJSON,
    RosettaMempoolTransactionRequestToJSON,
    RosettaMempoolTransactionResponse,
    RosettaMempoolTransactionResponseFromJSON,
    RosettaMempoolTransactionResponseToJSON,
    RosettaNetworkListResponse,
    RosettaNetworkListResponseFromJSON,
    RosettaNetworkListResponseToJSON,
    RosettaNetworkOptionsResponse,
    RosettaNetworkOptionsResponseFromJSON,
    RosettaNetworkOptionsResponseToJSON,
    RosettaNetworkStatusResponse,
    RosettaNetworkStatusResponseFromJSON,
    RosettaNetworkStatusResponseToJSON,
    RosettaOptionsRequest,
    RosettaOptionsRequestFromJSON,
    RosettaOptionsRequestToJSON,
    RosettaStatusRequest,
    RosettaStatusRequestFromJSON,
    RosettaStatusRequestToJSON,
} from '../models';

export interface RosettaAccountBalanceOperationRequest {
    rosettaAccountBalanceRequest: RosettaAccountBalanceRequest;
}

export interface RosettaBlockOperationRequest {
    rosettaBlockRequest: RosettaBlockRequest;
}

export interface RosettaBlockTransactionOperationRequest {
    rosettaBlockTransactionRequest: RosettaBlockTransactionRequest;
}

export interface RosettaConstructionCombineOperationRequest {
    rosettaConstructionCombineRequest: RosettaConstructionCombineRequest;
}

export interface RosettaConstructionDeriveOperationRequest {
    rosettaConstructionDeriveRequest: RosettaConstructionDeriveRequest;
}

export interface RosettaConstructionHashOperationRequest {
    rosettaConstructionHashRequest: RosettaConstructionHashRequest;
}

export interface RosettaConstructionMetadataOperationRequest {
    rosettaConstructionMetadataRequest: RosettaConstructionMetadataRequest;
}

export interface RosettaConstructionParseOperationRequest {
    rosettaConstructionParseRequest: RosettaConstructionParseRequest;
}

export interface RosettaConstructionPayloadsOperationRequest {
    rosettaConstructionPayloadsRequest: RosettaConstructionPayloadsRequest;
}

export interface RosettaConstructionPreprocessOperationRequest {
    rosettaConstructionPreprocessRequest: RosettaConstructionPreprocessRequest;
}

export interface RosettaConstructionSubmitOperationRequest {
    rosettaConstructionSubmitRequest: RosettaConstructionSubmitRequest;
}

export interface RosettaMempoolOperationRequest {
    rosettaMempoolRequest: RosettaMempoolRequest;
}

export interface RosettaMempoolTransactionOperationRequest {
    rosettaMempoolTransactionRequest: RosettaMempoolTransactionRequest;
}

export interface RosettaNetworkOptionsRequest {
    rosettaOptionsRequest: RosettaOptionsRequest;
}

export interface RosettaNetworkStatusRequest {
    rosettaStatusRequest: RosettaStatusRequest;
}

/**
 * RosettaApi - interface
 * 
 * @export
 * @interface RosettaApiInterface
 */
export interface RosettaApiInterface {
    /**
     * An AccountBalanceRequest is utilized to make a balance request on the /account/balance endpoint. If the block_identifier is populated, a historical balance query should be performed. 
     * @summary Get an Account Balance
     * @param {RosettaAccountBalanceRequest} rosettaAccountBalanceRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RosettaApiInterface
     */
    rosettaAccountBalanceRaw(requestParameters: RosettaAccountBalanceOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RosettaAccountBalanceResponse>>;

    /**
     * An AccountBalanceRequest is utilized to make a balance request on the /account/balance endpoint. If the block_identifier is populated, a historical balance query should be performed. 
     * Get an Account Balance
     */
    rosettaAccountBalance(requestParameters: RosettaAccountBalanceOperationRequest, initOverrides?: RequestInit): Promise<RosettaAccountBalanceResponse>;

    /**
     * Retrieves the Block information for a given block identifier including a list of all transactions in the block.
     * @summary Get a Block
     * @param {RosettaBlockRequest} rosettaBlockRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RosettaApiInterface
     */
    rosettaBlockRaw(requestParameters: RosettaBlockOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RosettaBlockResponse>>;

    /**
     * Retrieves the Block information for a given block identifier including a list of all transactions in the block.
     * Get a Block
     */
    rosettaBlock(requestParameters: RosettaBlockOperationRequest, initOverrides?: RequestInit): Promise<RosettaBlockResponse>;

    /**
     * Retrieves a Transaction included in a block that is not returned in a BlockResponse.
     * @summary Get a Block Transaction
     * @param {RosettaBlockTransactionRequest} rosettaBlockTransactionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RosettaApiInterface
     */
    rosettaBlockTransactionRaw(requestParameters: RosettaBlockTransactionOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RosettaBlockTransactionResponse>>;

    /**
     * Retrieves a Transaction included in a block that is not returned in a BlockResponse.
     * Get a Block Transaction
     */
    rosettaBlockTransaction(requestParameters: RosettaBlockTransactionOperationRequest, initOverrides?: RequestInit): Promise<RosettaBlockTransactionResponse>;

    /**
     * Take unsigned transaction and signature, combine both and return signed transaction. The examples below are illustrative only. You\'ll need to use your wallet to generate actual values to use them in the request payload.
     * @summary Create Network Transaction from Signatures
     * @param {RosettaConstructionCombineRequest} rosettaConstructionCombineRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RosettaApiInterface
     */
    rosettaConstructionCombineRaw(requestParameters: RosettaConstructionCombineOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RosettaConstructionCombineResponse>>;

    /**
     * Take unsigned transaction and signature, combine both and return signed transaction. The examples below are illustrative only. You\'ll need to use your wallet to generate actual values to use them in the request payload.
     * Create Network Transaction from Signatures
     */
    rosettaConstructionCombine(requestParameters: RosettaConstructionCombineOperationRequest, initOverrides?: RequestInit): Promise<RosettaConstructionCombineResponse>;

    /**
     * Retrieves the Account Identifier information based on a Public Key for a given network
     * @summary Derive an AccountIdentifier from a PublicKey
     * @param {RosettaConstructionDeriveRequest} rosettaConstructionDeriveRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RosettaApiInterface
     */
    rosettaConstructionDeriveRaw(requestParameters: RosettaConstructionDeriveOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RosettaConstructionDeriveResponse>>;

    /**
     * Retrieves the Account Identifier information based on a Public Key for a given network
     * Derive an AccountIdentifier from a PublicKey
     */
    rosettaConstructionDerive(requestParameters: RosettaConstructionDeriveOperationRequest, initOverrides?: RequestInit): Promise<RosettaConstructionDeriveResponse>;

    /**
     * Retrieves the network-specific transaction hash for a signed transaction.
     * @summary Get the Hash of a Signed Transaction
     * @param {RosettaConstructionHashRequest} rosettaConstructionHashRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RosettaApiInterface
     */
    rosettaConstructionHashRaw(requestParameters: RosettaConstructionHashOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RosettaConstructionHashResponse>>;

    /**
     * Retrieves the network-specific transaction hash for a signed transaction.
     * Get the Hash of a Signed Transaction
     */
    rosettaConstructionHash(requestParameters: RosettaConstructionHashOperationRequest, initOverrides?: RequestInit): Promise<RosettaConstructionHashResponse>;

    /**
     * To Do
     * @summary Get Metadata for Transaction Construction
     * @param {RosettaConstructionMetadataRequest} rosettaConstructionMetadataRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RosettaApiInterface
     */
    rosettaConstructionMetadataRaw(requestParameters: RosettaConstructionMetadataOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RosettaConstructionMetadataResponse>>;

    /**
     * To Do
     * Get Metadata for Transaction Construction
     */
    rosettaConstructionMetadata(requestParameters: RosettaConstructionMetadataOperationRequest, initOverrides?: RequestInit): Promise<RosettaConstructionMetadataResponse>;

    /**
     * TODO
     * @summary Parse a Transaction
     * @param {RosettaConstructionParseRequest} rosettaConstructionParseRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RosettaApiInterface
     */
    rosettaConstructionParseRaw(requestParameters: RosettaConstructionParseOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RosettaConstructionParseResponse>>;

    /**
     * TODO
     * Parse a Transaction
     */
    rosettaConstructionParse(requestParameters: RosettaConstructionParseOperationRequest, initOverrides?: RequestInit): Promise<RosettaConstructionParseResponse>;

    /**
     * Generate an unsigned transaction from operations and metadata. The examples below are illustrative only. You\'ll need to use your wallet to generate actual values to use them in the request payload.
     * @summary Generate an Unsigned Transaction and Signing Payloads
     * @param {RosettaConstructionPayloadsRequest} rosettaConstructionPayloadsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RosettaApiInterface
     */
    rosettaConstructionPayloadsRaw(requestParameters: RosettaConstructionPayloadsOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RosettaConstructionPayloadResponse>>;

    /**
     * Generate an unsigned transaction from operations and metadata. The examples below are illustrative only. You\'ll need to use your wallet to generate actual values to use them in the request payload.
     * Generate an Unsigned Transaction and Signing Payloads
     */
    rosettaConstructionPayloads(requestParameters: RosettaConstructionPayloadsOperationRequest, initOverrides?: RequestInit): Promise<RosettaConstructionPayloadResponse>;

    /**
     * TODO
     * @summary Create a Request to Fetch Metadata
     * @param {RosettaConstructionPreprocessRequest} rosettaConstructionPreprocessRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RosettaApiInterface
     */
    rosettaConstructionPreprocessRaw(requestParameters: RosettaConstructionPreprocessOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RosettaConstructionPreprocessResponse>>;

    /**
     * TODO
     * Create a Request to Fetch Metadata
     */
    rosettaConstructionPreprocess(requestParameters: RosettaConstructionPreprocessOperationRequest, initOverrides?: RequestInit): Promise<RosettaConstructionPreprocessResponse>;

    /**
     * Submit a pre-signed transaction to the node. The examples below are illustrative only. You\'ll need to use your wallet to generate actual values to use them in the request payload.
     * @summary Submit a Signed Transaction
     * @param {RosettaConstructionSubmitRequest} rosettaConstructionSubmitRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RosettaApiInterface
     */
    rosettaConstructionSubmitRaw(requestParameters: RosettaConstructionSubmitOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RosettaConstructionSubmitResponse>>;

    /**
     * Submit a pre-signed transaction to the node. The examples below are illustrative only. You\'ll need to use your wallet to generate actual values to use them in the request payload.
     * Submit a Signed Transaction
     */
    rosettaConstructionSubmit(requestParameters: RosettaConstructionSubmitOperationRequest, initOverrides?: RequestInit): Promise<RosettaConstructionSubmitResponse>;

    /**
     * Retrieves a list of transactions currently in the mempool for a given network.
     * @summary Get All Mempool Transactions
     * @param {RosettaMempoolRequest} rosettaMempoolRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RosettaApiInterface
     */
    rosettaMempoolRaw(requestParameters: RosettaMempoolOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RosettaMempoolResponse>>;

    /**
     * Retrieves a list of transactions currently in the mempool for a given network.
     * Get All Mempool Transactions
     */
    rosettaMempool(requestParameters: RosettaMempoolOperationRequest, initOverrides?: RequestInit): Promise<RosettaMempoolResponse>;

    /**
     * Retrieves transaction details from the mempool for a given transaction id from a given network.
     * @summary Get a Mempool Transaction
     * @param {RosettaMempoolTransactionRequest} rosettaMempoolTransactionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RosettaApiInterface
     */
    rosettaMempoolTransactionRaw(requestParameters: RosettaMempoolTransactionOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RosettaMempoolTransactionResponse>>;

    /**
     * Retrieves transaction details from the mempool for a given transaction id from a given network.
     * Get a Mempool Transaction
     */
    rosettaMempoolTransaction(requestParameters: RosettaMempoolTransactionOperationRequest, initOverrides?: RequestInit): Promise<RosettaMempoolTransactionResponse>;

    /**
     * Retrieves a list of NetworkIdentifiers that the Rosetta server supports.
     * @summary Get List of Available Networks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RosettaApiInterface
     */
    rosettaNetworkListRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<RosettaNetworkListResponse>>;

    /**
     * Retrieves a list of NetworkIdentifiers that the Rosetta server supports.
     * Get List of Available Networks
     */
    rosettaNetworkList(initOverrides?: RequestInit): Promise<RosettaNetworkListResponse>;

    /**
     * Retrieves the version information and allowed network-specific types for a NetworkIdentifier. Any NetworkIdentifier returned by /network/list should be accessible here. Because options are retrievable in the context of a NetworkIdentifier, it is possible to define unique options for each network. 
     * @summary Get Network Options
     * @param {RosettaOptionsRequest} rosettaOptionsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RosettaApiInterface
     */
    rosettaNetworkOptionsRaw(requestParameters: RosettaNetworkOptionsRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RosettaNetworkOptionsResponse>>;

    /**
     * Retrieves the version information and allowed network-specific types for a NetworkIdentifier. Any NetworkIdentifier returned by /network/list should be accessible here. Because options are retrievable in the context of a NetworkIdentifier, it is possible to define unique options for each network. 
     * Get Network Options
     */
    rosettaNetworkOptions(requestParameters: RosettaNetworkOptionsRequest, initOverrides?: RequestInit): Promise<RosettaNetworkOptionsResponse>;

    /**
     * Retrieves the current status of the network requested. Any NetworkIdentifier returned by /network/list should be accessible here. 
     * @summary Get Network Status
     * @param {RosettaStatusRequest} rosettaStatusRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RosettaApiInterface
     */
    rosettaNetworkStatusRaw(requestParameters: RosettaNetworkStatusRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RosettaNetworkStatusResponse>>;

    /**
     * Retrieves the current status of the network requested. Any NetworkIdentifier returned by /network/list should be accessible here. 
     * Get Network Status
     */
    rosettaNetworkStatus(requestParameters: RosettaNetworkStatusRequest, initOverrides?: RequestInit): Promise<RosettaNetworkStatusResponse>;

}

/**
 * 
 */
export class RosettaApi extends runtime.BaseAPI implements RosettaApiInterface {

    /**
     * An AccountBalanceRequest is utilized to make a balance request on the /account/balance endpoint. If the block_identifier is populated, a historical balance query should be performed. 
     * Get an Account Balance
     */
    async rosettaAccountBalanceRaw(requestParameters: RosettaAccountBalanceOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RosettaAccountBalanceResponse>> {
        if (requestParameters.rosettaAccountBalanceRequest === null || requestParameters.rosettaAccountBalanceRequest === undefined) {
            throw new runtime.RequiredError('rosettaAccountBalanceRequest','Required parameter requestParameters.rosettaAccountBalanceRequest was null or undefined when calling rosettaAccountBalance.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/rosetta/v1/account/balance`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RosettaAccountBalanceRequestToJSON(requestParameters.rosettaAccountBalanceRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RosettaAccountBalanceResponseFromJSON(jsonValue));
    }

    /**
     * An AccountBalanceRequest is utilized to make a balance request on the /account/balance endpoint. If the block_identifier is populated, a historical balance query should be performed. 
     * Get an Account Balance
     */
    async rosettaAccountBalance(requestParameters: RosettaAccountBalanceOperationRequest, initOverrides?: RequestInit): Promise<RosettaAccountBalanceResponse> {
        const response = await this.rosettaAccountBalanceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves the Block information for a given block identifier including a list of all transactions in the block.
     * Get a Block
     */
    async rosettaBlockRaw(requestParameters: RosettaBlockOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RosettaBlockResponse>> {
        if (requestParameters.rosettaBlockRequest === null || requestParameters.rosettaBlockRequest === undefined) {
            throw new runtime.RequiredError('rosettaBlockRequest','Required parameter requestParameters.rosettaBlockRequest was null or undefined when calling rosettaBlock.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/rosetta/v1/block`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RosettaBlockRequestToJSON(requestParameters.rosettaBlockRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RosettaBlockResponseFromJSON(jsonValue));
    }

    /**
     * Retrieves the Block information for a given block identifier including a list of all transactions in the block.
     * Get a Block
     */
    async rosettaBlock(requestParameters: RosettaBlockOperationRequest, initOverrides?: RequestInit): Promise<RosettaBlockResponse> {
        const response = await this.rosettaBlockRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves a Transaction included in a block that is not returned in a BlockResponse.
     * Get a Block Transaction
     */
    async rosettaBlockTransactionRaw(requestParameters: RosettaBlockTransactionOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RosettaBlockTransactionResponse>> {
        if (requestParameters.rosettaBlockTransactionRequest === null || requestParameters.rosettaBlockTransactionRequest === undefined) {
            throw new runtime.RequiredError('rosettaBlockTransactionRequest','Required parameter requestParameters.rosettaBlockTransactionRequest was null or undefined when calling rosettaBlockTransaction.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/rosetta/v1/block/transaction`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RosettaBlockTransactionRequestToJSON(requestParameters.rosettaBlockTransactionRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RosettaBlockTransactionResponseFromJSON(jsonValue));
    }

    /**
     * Retrieves a Transaction included in a block that is not returned in a BlockResponse.
     * Get a Block Transaction
     */
    async rosettaBlockTransaction(requestParameters: RosettaBlockTransactionOperationRequest, initOverrides?: RequestInit): Promise<RosettaBlockTransactionResponse> {
        const response = await this.rosettaBlockTransactionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Take unsigned transaction and signature, combine both and return signed transaction. The examples below are illustrative only. You\'ll need to use your wallet to generate actual values to use them in the request payload.
     * Create Network Transaction from Signatures
     */
    async rosettaConstructionCombineRaw(requestParameters: RosettaConstructionCombineOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RosettaConstructionCombineResponse>> {
        if (requestParameters.rosettaConstructionCombineRequest === null || requestParameters.rosettaConstructionCombineRequest === undefined) {
            throw new runtime.RequiredError('rosettaConstructionCombineRequest','Required parameter requestParameters.rosettaConstructionCombineRequest was null or undefined when calling rosettaConstructionCombine.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/rosetta/v1/construction/combine`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RosettaConstructionCombineRequestToJSON(requestParameters.rosettaConstructionCombineRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RosettaConstructionCombineResponseFromJSON(jsonValue));
    }

    /**
     * Take unsigned transaction and signature, combine both and return signed transaction. The examples below are illustrative only. You\'ll need to use your wallet to generate actual values to use them in the request payload.
     * Create Network Transaction from Signatures
     */
    async rosettaConstructionCombine(requestParameters: RosettaConstructionCombineOperationRequest, initOverrides?: RequestInit): Promise<RosettaConstructionCombineResponse> {
        const response = await this.rosettaConstructionCombineRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves the Account Identifier information based on a Public Key for a given network
     * Derive an AccountIdentifier from a PublicKey
     */
    async rosettaConstructionDeriveRaw(requestParameters: RosettaConstructionDeriveOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RosettaConstructionDeriveResponse>> {
        if (requestParameters.rosettaConstructionDeriveRequest === null || requestParameters.rosettaConstructionDeriveRequest === undefined) {
            throw new runtime.RequiredError('rosettaConstructionDeriveRequest','Required parameter requestParameters.rosettaConstructionDeriveRequest was null or undefined when calling rosettaConstructionDerive.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/rosetta/v1/construction/derive`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RosettaConstructionDeriveRequestToJSON(requestParameters.rosettaConstructionDeriveRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RosettaConstructionDeriveResponseFromJSON(jsonValue));
    }

    /**
     * Retrieves the Account Identifier information based on a Public Key for a given network
     * Derive an AccountIdentifier from a PublicKey
     */
    async rosettaConstructionDerive(requestParameters: RosettaConstructionDeriveOperationRequest, initOverrides?: RequestInit): Promise<RosettaConstructionDeriveResponse> {
        const response = await this.rosettaConstructionDeriveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves the network-specific transaction hash for a signed transaction.
     * Get the Hash of a Signed Transaction
     */
    async rosettaConstructionHashRaw(requestParameters: RosettaConstructionHashOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RosettaConstructionHashResponse>> {
        if (requestParameters.rosettaConstructionHashRequest === null || requestParameters.rosettaConstructionHashRequest === undefined) {
            throw new runtime.RequiredError('rosettaConstructionHashRequest','Required parameter requestParameters.rosettaConstructionHashRequest was null or undefined when calling rosettaConstructionHash.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/rosetta/v1/construction/hash`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RosettaConstructionHashRequestToJSON(requestParameters.rosettaConstructionHashRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RosettaConstructionHashResponseFromJSON(jsonValue));
    }

    /**
     * Retrieves the network-specific transaction hash for a signed transaction.
     * Get the Hash of a Signed Transaction
     */
    async rosettaConstructionHash(requestParameters: RosettaConstructionHashOperationRequest, initOverrides?: RequestInit): Promise<RosettaConstructionHashResponse> {
        const response = await this.rosettaConstructionHashRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * To Do
     * Get Metadata for Transaction Construction
     */
    async rosettaConstructionMetadataRaw(requestParameters: RosettaConstructionMetadataOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RosettaConstructionMetadataResponse>> {
        if (requestParameters.rosettaConstructionMetadataRequest === null || requestParameters.rosettaConstructionMetadataRequest === undefined) {
            throw new runtime.RequiredError('rosettaConstructionMetadataRequest','Required parameter requestParameters.rosettaConstructionMetadataRequest was null or undefined when calling rosettaConstructionMetadata.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/rosetta/v1/construction/metadata`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RosettaConstructionMetadataRequestToJSON(requestParameters.rosettaConstructionMetadataRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RosettaConstructionMetadataResponseFromJSON(jsonValue));
    }

    /**
     * To Do
     * Get Metadata for Transaction Construction
     */
    async rosettaConstructionMetadata(requestParameters: RosettaConstructionMetadataOperationRequest, initOverrides?: RequestInit): Promise<RosettaConstructionMetadataResponse> {
        const response = await this.rosettaConstructionMetadataRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * TODO
     * Parse a Transaction
     */
    async rosettaConstructionParseRaw(requestParameters: RosettaConstructionParseOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RosettaConstructionParseResponse>> {
        if (requestParameters.rosettaConstructionParseRequest === null || requestParameters.rosettaConstructionParseRequest === undefined) {
            throw new runtime.RequiredError('rosettaConstructionParseRequest','Required parameter requestParameters.rosettaConstructionParseRequest was null or undefined when calling rosettaConstructionParse.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/rosetta/v1/construction/parse`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RosettaConstructionParseRequestToJSON(requestParameters.rosettaConstructionParseRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RosettaConstructionParseResponseFromJSON(jsonValue));
    }

    /**
     * TODO
     * Parse a Transaction
     */
    async rosettaConstructionParse(requestParameters: RosettaConstructionParseOperationRequest, initOverrides?: RequestInit): Promise<RosettaConstructionParseResponse> {
        const response = await this.rosettaConstructionParseRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Generate an unsigned transaction from operations and metadata. The examples below are illustrative only. You\'ll need to use your wallet to generate actual values to use them in the request payload.
     * Generate an Unsigned Transaction and Signing Payloads
     */
    async rosettaConstructionPayloadsRaw(requestParameters: RosettaConstructionPayloadsOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RosettaConstructionPayloadResponse>> {
        if (requestParameters.rosettaConstructionPayloadsRequest === null || requestParameters.rosettaConstructionPayloadsRequest === undefined) {
            throw new runtime.RequiredError('rosettaConstructionPayloadsRequest','Required parameter requestParameters.rosettaConstructionPayloadsRequest was null or undefined when calling rosettaConstructionPayloads.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/rosetta/v1/construction/payloads`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RosettaConstructionPayloadsRequestToJSON(requestParameters.rosettaConstructionPayloadsRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RosettaConstructionPayloadResponseFromJSON(jsonValue));
    }

    /**
     * Generate an unsigned transaction from operations and metadata. The examples below are illustrative only. You\'ll need to use your wallet to generate actual values to use them in the request payload.
     * Generate an Unsigned Transaction and Signing Payloads
     */
    async rosettaConstructionPayloads(requestParameters: RosettaConstructionPayloadsOperationRequest, initOverrides?: RequestInit): Promise<RosettaConstructionPayloadResponse> {
        const response = await this.rosettaConstructionPayloadsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * TODO
     * Create a Request to Fetch Metadata
     */
    async rosettaConstructionPreprocessRaw(requestParameters: RosettaConstructionPreprocessOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RosettaConstructionPreprocessResponse>> {
        if (requestParameters.rosettaConstructionPreprocessRequest === null || requestParameters.rosettaConstructionPreprocessRequest === undefined) {
            throw new runtime.RequiredError('rosettaConstructionPreprocessRequest','Required parameter requestParameters.rosettaConstructionPreprocessRequest was null or undefined when calling rosettaConstructionPreprocess.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/rosetta/v1/construction/preprocess`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RosettaConstructionPreprocessRequestToJSON(requestParameters.rosettaConstructionPreprocessRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RosettaConstructionPreprocessResponseFromJSON(jsonValue));
    }

    /**
     * TODO
     * Create a Request to Fetch Metadata
     */
    async rosettaConstructionPreprocess(requestParameters: RosettaConstructionPreprocessOperationRequest, initOverrides?: RequestInit): Promise<RosettaConstructionPreprocessResponse> {
        const response = await this.rosettaConstructionPreprocessRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Submit a pre-signed transaction to the node. The examples below are illustrative only. You\'ll need to use your wallet to generate actual values to use them in the request payload.
     * Submit a Signed Transaction
     */
    async rosettaConstructionSubmitRaw(requestParameters: RosettaConstructionSubmitOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RosettaConstructionSubmitResponse>> {
        if (requestParameters.rosettaConstructionSubmitRequest === null || requestParameters.rosettaConstructionSubmitRequest === undefined) {
            throw new runtime.RequiredError('rosettaConstructionSubmitRequest','Required parameter requestParameters.rosettaConstructionSubmitRequest was null or undefined when calling rosettaConstructionSubmit.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/rosetta/v1/construction/submit`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RosettaConstructionSubmitRequestToJSON(requestParameters.rosettaConstructionSubmitRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RosettaConstructionSubmitResponseFromJSON(jsonValue));
    }

    /**
     * Submit a pre-signed transaction to the node. The examples below are illustrative only. You\'ll need to use your wallet to generate actual values to use them in the request payload.
     * Submit a Signed Transaction
     */
    async rosettaConstructionSubmit(requestParameters: RosettaConstructionSubmitOperationRequest, initOverrides?: RequestInit): Promise<RosettaConstructionSubmitResponse> {
        const response = await this.rosettaConstructionSubmitRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves a list of transactions currently in the mempool for a given network.
     * Get All Mempool Transactions
     */
    async rosettaMempoolRaw(requestParameters: RosettaMempoolOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RosettaMempoolResponse>> {
        if (requestParameters.rosettaMempoolRequest === null || requestParameters.rosettaMempoolRequest === undefined) {
            throw new runtime.RequiredError('rosettaMempoolRequest','Required parameter requestParameters.rosettaMempoolRequest was null or undefined when calling rosettaMempool.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/rosetta/v1/mempool`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RosettaMempoolRequestToJSON(requestParameters.rosettaMempoolRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RosettaMempoolResponseFromJSON(jsonValue));
    }

    /**
     * Retrieves a list of transactions currently in the mempool for a given network.
     * Get All Mempool Transactions
     */
    async rosettaMempool(requestParameters: RosettaMempoolOperationRequest, initOverrides?: RequestInit): Promise<RosettaMempoolResponse> {
        const response = await this.rosettaMempoolRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves transaction details from the mempool for a given transaction id from a given network.
     * Get a Mempool Transaction
     */
    async rosettaMempoolTransactionRaw(requestParameters: RosettaMempoolTransactionOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RosettaMempoolTransactionResponse>> {
        if (requestParameters.rosettaMempoolTransactionRequest === null || requestParameters.rosettaMempoolTransactionRequest === undefined) {
            throw new runtime.RequiredError('rosettaMempoolTransactionRequest','Required parameter requestParameters.rosettaMempoolTransactionRequest was null or undefined when calling rosettaMempoolTransaction.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/rosetta/v1/mempool/transaction`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RosettaMempoolTransactionRequestToJSON(requestParameters.rosettaMempoolTransactionRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RosettaMempoolTransactionResponseFromJSON(jsonValue));
    }

    /**
     * Retrieves transaction details from the mempool for a given transaction id from a given network.
     * Get a Mempool Transaction
     */
    async rosettaMempoolTransaction(requestParameters: RosettaMempoolTransactionOperationRequest, initOverrides?: RequestInit): Promise<RosettaMempoolTransactionResponse> {
        const response = await this.rosettaMempoolTransactionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves a list of NetworkIdentifiers that the Rosetta server supports.
     * Get List of Available Networks
     */
    async rosettaNetworkListRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<RosettaNetworkListResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/rosetta/v1/network/list`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RosettaNetworkListResponseFromJSON(jsonValue));
    }

    /**
     * Retrieves a list of NetworkIdentifiers that the Rosetta server supports.
     * Get List of Available Networks
     */
    async rosettaNetworkList(initOverrides?: RequestInit): Promise<RosettaNetworkListResponse> {
        const response = await this.rosettaNetworkListRaw(initOverrides);
        return await response.value();
    }

    /**
     * Retrieves the version information and allowed network-specific types for a NetworkIdentifier. Any NetworkIdentifier returned by /network/list should be accessible here. Because options are retrievable in the context of a NetworkIdentifier, it is possible to define unique options for each network. 
     * Get Network Options
     */
    async rosettaNetworkOptionsRaw(requestParameters: RosettaNetworkOptionsRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RosettaNetworkOptionsResponse>> {
        if (requestParameters.rosettaOptionsRequest === null || requestParameters.rosettaOptionsRequest === undefined) {
            throw new runtime.RequiredError('rosettaOptionsRequest','Required parameter requestParameters.rosettaOptionsRequest was null or undefined when calling rosettaNetworkOptions.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/rosetta/v1/network/options`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RosettaOptionsRequestToJSON(requestParameters.rosettaOptionsRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RosettaNetworkOptionsResponseFromJSON(jsonValue));
    }

    /**
     * Retrieves the version information and allowed network-specific types for a NetworkIdentifier. Any NetworkIdentifier returned by /network/list should be accessible here. Because options are retrievable in the context of a NetworkIdentifier, it is possible to define unique options for each network. 
     * Get Network Options
     */
    async rosettaNetworkOptions(requestParameters: RosettaNetworkOptionsRequest, initOverrides?: RequestInit): Promise<RosettaNetworkOptionsResponse> {
        const response = await this.rosettaNetworkOptionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves the current status of the network requested. Any NetworkIdentifier returned by /network/list should be accessible here. 
     * Get Network Status
     */
    async rosettaNetworkStatusRaw(requestParameters: RosettaNetworkStatusRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RosettaNetworkStatusResponse>> {
        if (requestParameters.rosettaStatusRequest === null || requestParameters.rosettaStatusRequest === undefined) {
            throw new runtime.RequiredError('rosettaStatusRequest','Required parameter requestParameters.rosettaStatusRequest was null or undefined when calling rosettaNetworkStatus.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/rosetta/v1/network/status`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RosettaStatusRequestToJSON(requestParameters.rosettaStatusRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RosettaNetworkStatusResponseFromJSON(jsonValue));
    }

    /**
     * Retrieves the current status of the network requested. Any NetworkIdentifier returned by /network/list should be accessible here. 
     * Get Network Status
     */
    async rosettaNetworkStatus(requestParameters: RosettaNetworkStatusRequest, initOverrides?: RequestInit): Promise<RosettaNetworkStatusResponse> {
        const response = await this.rosettaNetworkStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

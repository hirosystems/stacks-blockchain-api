/* tslint:disable */
/* eslint-disable */
/**
 * Stacks Blockchain API
 * Welcome to the API reference overview for the <a href=\"https://docs.hiro.so/get-started/stacks-blockchain-api\">Stacks Blockchain API</a>.  <a href=\"https://hirosystems.github.io/stacks-blockchain-api/collection.json\" download=\"stacks-api-collection.json\">Download Postman collection</a> 
 *
 * The version of the OpenAPI document: STACKS_API_VERSION
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    GetRawTransactionResult,
    GetRawTransactionResultFromJSON,
    GetRawTransactionResultToJSON,
    MempoolTransactionListResponse,
    MempoolTransactionListResponseFromJSON,
    MempoolTransactionListResponseToJSON,
    MempoolTransactionStatsResponse,
    MempoolTransactionStatsResponseFromJSON,
    MempoolTransactionStatsResponseToJSON,
    PostCoreNodeTransactionsError,
    PostCoreNodeTransactionsErrorFromJSON,
    PostCoreNodeTransactionsErrorToJSON,
    TransactionEventsResponse,
    TransactionEventsResponseFromJSON,
    TransactionEventsResponseToJSON,
    TransactionResults,
    TransactionResultsFromJSON,
    TransactionResultsToJSON,
} from '../models';

export interface GetAddressMempoolTransactionsRequest {
    address: string;
    limit?: number;
    offset?: number;
    unanchored?: boolean;
}

export interface GetDroppedMempoolTransactionListRequest {
    limit?: number;
    offset?: number;
}

export interface GetFilteredEventsRequest {
    txId?: string;
    address?: string;
    limit?: number;
    offset?: number;
    type?: Array<GetFilteredEventsTypeEnum>;
}

export interface GetMempoolTransactionListRequest {
    senderAddress?: string;
    recipientAddress?: string;
    address?: string;
    limit?: number;
    offset?: number;
    unanchored?: boolean;
}

export interface GetRawTransactionByIdRequest {
    txId: string;
}

export interface GetTransactionByIdRequest {
    txId: string;
    eventOffset?: number;
    eventLimit?: number;
    unanchored?: boolean;
}

export interface GetTransactionListRequest {
    limit?: number;
    offset?: number;
    type?: Array<GetTransactionListTypeEnum>;
    unanchored?: boolean;
}

export interface GetTransactionsByBlockHashRequest {
    blockHash: string;
    limit?: number;
    offset?: number;
}

export interface GetTransactionsByBlockHeightRequest {
    height: number;
    limit?: number;
    offset?: number;
    unanchored?: boolean;
}

export interface GetTxListDetailsRequest {
    txId: Array<string>;
    eventOffset?: number;
    eventLimit?: number;
    unanchored?: boolean;
}

export interface PostCoreNodeTransactionsRequest {
    body?: Blob;
}

/**
 * TransactionsApi - interface
 * 
 * @export
 * @interface TransactionsApiInterface
 */
export interface TransactionsApiInterface {
    /**
     * Retrieves all transactions for a given address that are currently in mempool
     * @summary Transactions for address
     * @param {string} address Transactions for the address
     * @param {number} [limit] max number of transactions to fetch
     * @param {number} [offset] index of first transaction to fetch
     * @param {boolean} [unanchored] Include transaction data from unanchored (i.e. unconfirmed) microblocks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApiInterface
     */
    getAddressMempoolTransactionsRaw(requestParameters: GetAddressMempoolTransactionsRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<MempoolTransactionListResponse>>;

    /**
     * Retrieves all transactions for a given address that are currently in mempool
     * Transactions for address
     */
    getAddressMempoolTransactions(requestParameters: GetAddressMempoolTransactionsRequest, initOverrides?: RequestInit): Promise<MempoolTransactionListResponse>;

    /**
     * Retrieves all recently-broadcast transactions that have been dropped from the mempool.  Transactions are dropped from the mempool if:  * they were stale and awaiting garbage collection or,  * were expensive,  or  * were replaced with a new fee 
     * @summary Get dropped mempool transactions
     * @param {number} [limit] max number of mempool transactions to fetch
     * @param {number} [offset] index of first mempool transaction to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApiInterface
     */
    getDroppedMempoolTransactionListRaw(requestParameters: GetDroppedMempoolTransactionListRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<MempoolTransactionListResponse>>;

    /**
     * Retrieves all recently-broadcast transactions that have been dropped from the mempool.  Transactions are dropped from the mempool if:  * they were stale and awaiting garbage collection or,  * were expensive,  or  * were replaced with a new fee 
     * Get dropped mempool transactions
     */
    getDroppedMempoolTransactionList(requestParameters: GetDroppedMempoolTransactionListRequest, initOverrides?: RequestInit): Promise<MempoolTransactionListResponse>;

    /**
     * Retrieves the list of events filtered by principal (STX address or Smart Contract ID), transaction id or event types. The list of event types is (\'smart_contract_log\', \'stx_lock\', \'stx_asset\', \'fungible_token_asset\', \'non_fungible_token_asset\').
     * @summary Transaction Events
     * @param {string} [txId] Hash of transaction
     * @param {string} [address] Stacks address or a Contract identifier
     * @param {number} [limit] number of items to return
     * @param {number} [offset] number of items to skip
     * @param {Array<'smart_contract_log' | 'stx_lock' | 'stx_asset' | 'fungible_token_asset' | 'non_fungible_token_asset'>} [type] Filter the events on event type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApiInterface
     */
    getFilteredEventsRaw(requestParameters: GetFilteredEventsRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<TransactionEventsResponse>>;

    /**
     * Retrieves the list of events filtered by principal (STX address or Smart Contract ID), transaction id or event types. The list of event types is (\'smart_contract_log\', \'stx_lock\', \'stx_asset\', \'fungible_token_asset\', \'non_fungible_token_asset\').
     * Transaction Events
     */
    getFilteredEvents(requestParameters: GetFilteredEventsRequest, initOverrides?: RequestInit): Promise<TransactionEventsResponse>;

    /**
     * Retrieves all transactions that have been recently broadcast to the mempool. These are pending transactions awaiting confirmation.  If you need to monitor new transactions, we highly recommend subscribing to [WebSockets or Socket.io](https://github.com/hirosystems/stacks-blockchain-api/tree/master/client) for real-time updates. 
     * @summary Get mempool transactions
     * @param {string} [senderAddress] Filter to only return transactions with this sender address.
     * @param {string} [recipientAddress] Filter to only return transactions with this recipient address (only applicable for STX transfer tx types).
     * @param {string} [address] Filter to only return transactions with this address as the sender or recipient (recipient only applicable for STX transfer tx types).
     * @param {number} [limit] max number of mempool transactions to fetch
     * @param {number} [offset] index of first mempool transaction to fetch
     * @param {boolean} [unanchored] Include transaction data from unanchored (i.e. unconfirmed) microblocks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApiInterface
     */
    getMempoolTransactionListRaw(requestParameters: GetMempoolTransactionListRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<MempoolTransactionListResponse>>;

    /**
     * Retrieves all transactions that have been recently broadcast to the mempool. These are pending transactions awaiting confirmation.  If you need to monitor new transactions, we highly recommend subscribing to [WebSockets or Socket.io](https://github.com/hirosystems/stacks-blockchain-api/tree/master/client) for real-time updates. 
     * Get mempool transactions
     */
    getMempoolTransactionList(requestParameters: GetMempoolTransactionListRequest, initOverrides?: RequestInit): Promise<MempoolTransactionListResponse>;

    /**
     * Queries for transactions counts, age (by block height), fees (simple average), and size. All results broken down by transaction type and percentiles (p25, p50, p75, p95). 
     * @summary Get statistics for mempool transactions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApiInterface
     */
    getMempoolTransactionStatsRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<MempoolTransactionStatsResponse>>;

    /**
     * Queries for transactions counts, age (by block height), fees (simple average), and size. All results broken down by transaction type and percentiles (p25, p50, p75, p95). 
     * Get statistics for mempool transactions
     */
    getMempoolTransactionStats(initOverrides?: RequestInit): Promise<MempoolTransactionStatsResponse>;

    /**
     * Retrieves a hex encoded serialized transaction for a given ID 
     * @summary Get Raw Transaction
     * @param {string} txId Hash of transaction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApiInterface
     */
    getRawTransactionByIdRaw(requestParameters: GetRawTransactionByIdRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<GetRawTransactionResult>>;

    /**
     * Retrieves a hex encoded serialized transaction for a given ID 
     * Get Raw Transaction
     */
    getRawTransactionById(requestParameters: GetRawTransactionByIdRequest, initOverrides?: RequestInit): Promise<GetRawTransactionResult>;

    /**
     * Retrieves transaction details for a given transaction ID  `import type { Transaction } from \'@stacks/stacks-blockchain-api-types\';` 
     * @summary Get transaction
     * @param {string} txId Hash of transaction
     * @param {number} [eventOffset] The number of events to skip
     * @param {number} [eventLimit] The numbers of events to return
     * @param {boolean} [unanchored] Include transaction data from unanchored (i.e. unconfirmed) microblocks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApiInterface
     */
    getTransactionByIdRaw(requestParameters: GetTransactionByIdRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<object>>;

    /**
     * Retrieves transaction details for a given transaction ID  `import type { Transaction } from \'@stacks/stacks-blockchain-api-types\';` 
     * Get transaction
     */
    getTransactionById(requestParameters: GetTransactionByIdRequest, initOverrides?: RequestInit): Promise<object>;

    /**
     * Retrieves all recently mined transactions  If using TypeScript, import typings for this response from our types package:  `import type { TransactionResults } from \'@stacks/stacks-blockchain-api-types\';` 
     * @summary Get recent transactions
     * @param {number} [limit] max number of transactions to fetch
     * @param {number} [offset] index of first transaction to fetch
     * @param {Array<'coinbase' | 'token_transfer' | 'smart_contract' | 'contract_call' | 'poison_microblock'>} [type] Filter by transaction type
     * @param {boolean} [unanchored] Include transaction data from unanchored (i.e. unconfirmed) microblocks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApiInterface
     */
    getTransactionListRaw(requestParameters: GetTransactionListRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<TransactionResults>>;

    /**
     * Retrieves all recently mined transactions  If using TypeScript, import typings for this response from our types package:  `import type { TransactionResults } from \'@stacks/stacks-blockchain-api-types\';` 
     * Get recent transactions
     */
    getTransactionList(requestParameters: GetTransactionListRequest, initOverrides?: RequestInit): Promise<TransactionResults>;

    /**
     * Retrieves a list of all transactions within a block for a given block hash.
     * @summary Transactions by block hash
     * @param {string} blockHash Hash of block
     * @param {number} [limit] max number of transactions to fetch
     * @param {number} [offset] index of first transaction to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApiInterface
     */
    getTransactionsByBlockHashRaw(requestParameters: GetTransactionsByBlockHashRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<TransactionResults>>;

    /**
     * Retrieves a list of all transactions within a block for a given block hash.
     * Transactions by block hash
     */
    getTransactionsByBlockHash(requestParameters: GetTransactionsByBlockHashRequest, initOverrides?: RequestInit): Promise<TransactionResults>;

    /**
     * Retrieves all transactions within a block at a given height
     * @summary Transactions by block height
     * @param {number} height Height of block
     * @param {number} [limit] max number of transactions to fetch
     * @param {number} [offset] index of first transaction to fetch
     * @param {boolean} [unanchored] Include transaction data from unanchored (i.e. unconfirmed) microblocks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApiInterface
     */
    getTransactionsByBlockHeightRaw(requestParameters: GetTransactionsByBlockHeightRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<TransactionResults>>;

    /**
     * Retrieves all transactions within a block at a given height
     * Transactions by block height
     */
    getTransactionsByBlockHeight(requestParameters: GetTransactionsByBlockHeightRequest, initOverrides?: RequestInit): Promise<TransactionResults>;

    /**
     * Retrieves a list of transactions for a given list of transaction IDs  If using TypeScript, import typings for this response from our types package:  `import type { Transaction } from \'@stacks/stacks-blockchain-api-types\';` 
     * @summary Get list of details for transactions
     * @param {Array<string>} txId Array of transaction ids
     * @param {number} [eventOffset] The number of events to skip
     * @param {number} [eventLimit] The numbers of events to return
     * @param {boolean} [unanchored] Include transaction data from unanchored (i.e. unconfirmed) microblocks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApiInterface
     */
    getTxListDetailsRaw(requestParameters: GetTxListDetailsRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<{ [key: string]: object; }>>;

    /**
     * Retrieves a list of transactions for a given list of transaction IDs  If using TypeScript, import typings for this response from our types package:  `import type { Transaction } from \'@stacks/stacks-blockchain-api-types\';` 
     * Get list of details for transactions
     */
    getTxListDetails(requestParameters: GetTxListDetailsRequest, initOverrides?: RequestInit): Promise<{ [key: string]: object; }>;

    /**
     * Broadcasts raw transactions on the network. You can use the [@stacks/transactions](https://github.com/blockstack/stacks.js) project to generate a raw transaction payload.
     * @summary Broadcast raw transaction
     * @param {Blob} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApiInterface
     */
    postCoreNodeTransactionsRaw(requestParameters: PostCoreNodeTransactionsRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>>;

    /**
     * Broadcasts raw transactions on the network. You can use the [@stacks/transactions](https://github.com/blockstack/stacks.js) project to generate a raw transaction payload.
     * Broadcast raw transaction
     */
    postCoreNodeTransactions(requestParameters: PostCoreNodeTransactionsRequest, initOverrides?: RequestInit): Promise<string>;

}

/**
 * 
 */
export class TransactionsApi extends runtime.BaseAPI implements TransactionsApiInterface {

    /**
     * Retrieves all transactions for a given address that are currently in mempool
     * Transactions for address
     */
    async getAddressMempoolTransactionsRaw(requestParameters: GetAddressMempoolTransactionsRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<MempoolTransactionListResponse>> {
        if (requestParameters.address === null || requestParameters.address === undefined) {
            throw new runtime.RequiredError('address','Required parameter requestParameters.address was null or undefined when calling getAddressMempoolTransactions.');
        }

        const queryParameters: any = {};

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.unanchored !== undefined) {
            queryParameters['unanchored'] = requestParameters.unanchored;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/extended/v1/address/{address}/mempool`.replace(`{${"address"}}`, encodeURIComponent(String(requestParameters.address))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => MempoolTransactionListResponseFromJSON(jsonValue));
    }

    /**
     * Retrieves all transactions for a given address that are currently in mempool
     * Transactions for address
     */
    async getAddressMempoolTransactions(requestParameters: GetAddressMempoolTransactionsRequest, initOverrides?: RequestInit): Promise<MempoolTransactionListResponse> {
        const response = await this.getAddressMempoolTransactionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves all recently-broadcast transactions that have been dropped from the mempool.  Transactions are dropped from the mempool if:  * they were stale and awaiting garbage collection or,  * were expensive,  or  * were replaced with a new fee 
     * Get dropped mempool transactions
     */
    async getDroppedMempoolTransactionListRaw(requestParameters: GetDroppedMempoolTransactionListRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<MempoolTransactionListResponse>> {
        const queryParameters: any = {};

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/extended/v1/tx/mempool/dropped`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => MempoolTransactionListResponseFromJSON(jsonValue));
    }

    /**
     * Retrieves all recently-broadcast transactions that have been dropped from the mempool.  Transactions are dropped from the mempool if:  * they were stale and awaiting garbage collection or,  * were expensive,  or  * were replaced with a new fee 
     * Get dropped mempool transactions
     */
    async getDroppedMempoolTransactionList(requestParameters: GetDroppedMempoolTransactionListRequest, initOverrides?: RequestInit): Promise<MempoolTransactionListResponse> {
        const response = await this.getDroppedMempoolTransactionListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves the list of events filtered by principal (STX address or Smart Contract ID), transaction id or event types. The list of event types is (\'smart_contract_log\', \'stx_lock\', \'stx_asset\', \'fungible_token_asset\', \'non_fungible_token_asset\').
     * Transaction Events
     */
    async getFilteredEventsRaw(requestParameters: GetFilteredEventsRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<TransactionEventsResponse>> {
        const queryParameters: any = {};

        if (requestParameters.txId !== undefined) {
            queryParameters['tx_id'] = requestParameters.txId;
        }

        if (requestParameters.address !== undefined) {
            queryParameters['address'] = requestParameters.address;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.type) {
            queryParameters['type'] = requestParameters.type;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/extended/v1/tx/events`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TransactionEventsResponseFromJSON(jsonValue));
    }

    /**
     * Retrieves the list of events filtered by principal (STX address or Smart Contract ID), transaction id or event types. The list of event types is (\'smart_contract_log\', \'stx_lock\', \'stx_asset\', \'fungible_token_asset\', \'non_fungible_token_asset\').
     * Transaction Events
     */
    async getFilteredEvents(requestParameters: GetFilteredEventsRequest, initOverrides?: RequestInit): Promise<TransactionEventsResponse> {
        const response = await this.getFilteredEventsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves all transactions that have been recently broadcast to the mempool. These are pending transactions awaiting confirmation.  If you need to monitor new transactions, we highly recommend subscribing to [WebSockets or Socket.io](https://github.com/hirosystems/stacks-blockchain-api/tree/master/client) for real-time updates. 
     * Get mempool transactions
     */
    async getMempoolTransactionListRaw(requestParameters: GetMempoolTransactionListRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<MempoolTransactionListResponse>> {
        const queryParameters: any = {};

        if (requestParameters.senderAddress !== undefined) {
            queryParameters['sender_address'] = requestParameters.senderAddress;
        }

        if (requestParameters.recipientAddress !== undefined) {
            queryParameters['recipient_address'] = requestParameters.recipientAddress;
        }

        if (requestParameters.address !== undefined) {
            queryParameters['address'] = requestParameters.address;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.unanchored !== undefined) {
            queryParameters['unanchored'] = requestParameters.unanchored;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/extended/v1/tx/mempool`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => MempoolTransactionListResponseFromJSON(jsonValue));
    }

    /**
     * Retrieves all transactions that have been recently broadcast to the mempool. These are pending transactions awaiting confirmation.  If you need to monitor new transactions, we highly recommend subscribing to [WebSockets or Socket.io](https://github.com/hirosystems/stacks-blockchain-api/tree/master/client) for real-time updates. 
     * Get mempool transactions
     */
    async getMempoolTransactionList(requestParameters: GetMempoolTransactionListRequest, initOverrides?: RequestInit): Promise<MempoolTransactionListResponse> {
        const response = await this.getMempoolTransactionListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Queries for transactions counts, age (by block height), fees (simple average), and size. All results broken down by transaction type and percentiles (p25, p50, p75, p95). 
     * Get statistics for mempool transactions
     */
    async getMempoolTransactionStatsRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<MempoolTransactionStatsResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/extended/v1/tx/mempool/stats`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => MempoolTransactionStatsResponseFromJSON(jsonValue));
    }

    /**
     * Queries for transactions counts, age (by block height), fees (simple average), and size. All results broken down by transaction type and percentiles (p25, p50, p75, p95). 
     * Get statistics for mempool transactions
     */
    async getMempoolTransactionStats(initOverrides?: RequestInit): Promise<MempoolTransactionStatsResponse> {
        const response = await this.getMempoolTransactionStatsRaw(initOverrides);
        return await response.value();
    }

    /**
     * Retrieves a hex encoded serialized transaction for a given ID 
     * Get Raw Transaction
     */
    async getRawTransactionByIdRaw(requestParameters: GetRawTransactionByIdRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<GetRawTransactionResult>> {
        if (requestParameters.txId === null || requestParameters.txId === undefined) {
            throw new runtime.RequiredError('txId','Required parameter requestParameters.txId was null or undefined when calling getRawTransactionById.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/extended/v1/tx/{tx_id}/raw`.replace(`{${"tx_id"}}`, encodeURIComponent(String(requestParameters.txId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetRawTransactionResultFromJSON(jsonValue));
    }

    /**
     * Retrieves a hex encoded serialized transaction for a given ID 
     * Get Raw Transaction
     */
    async getRawTransactionById(requestParameters: GetRawTransactionByIdRequest, initOverrides?: RequestInit): Promise<GetRawTransactionResult> {
        const response = await this.getRawTransactionByIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves transaction details for a given transaction ID  `import type { Transaction } from \'@stacks/stacks-blockchain-api-types\';` 
     * Get transaction
     */
    async getTransactionByIdRaw(requestParameters: GetTransactionByIdRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.txId === null || requestParameters.txId === undefined) {
            throw new runtime.RequiredError('txId','Required parameter requestParameters.txId was null or undefined when calling getTransactionById.');
        }

        const queryParameters: any = {};

        if (requestParameters.eventOffset !== undefined) {
            queryParameters['event_offset'] = requestParameters.eventOffset;
        }

        if (requestParameters.eventLimit !== undefined) {
            queryParameters['event_limit'] = requestParameters.eventLimit;
        }

        if (requestParameters.unanchored !== undefined) {
            queryParameters['unanchored'] = requestParameters.unanchored;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/extended/v1/tx/{tx_id}`.replace(`{${"tx_id"}}`, encodeURIComponent(String(requestParameters.txId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Retrieves transaction details for a given transaction ID  `import type { Transaction } from \'@stacks/stacks-blockchain-api-types\';` 
     * Get transaction
     */
    async getTransactionById(requestParameters: GetTransactionByIdRequest, initOverrides?: RequestInit): Promise<object> {
        const response = await this.getTransactionByIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves all recently mined transactions  If using TypeScript, import typings for this response from our types package:  `import type { TransactionResults } from \'@stacks/stacks-blockchain-api-types\';` 
     * Get recent transactions
     */
    async getTransactionListRaw(requestParameters: GetTransactionListRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<TransactionResults>> {
        const queryParameters: any = {};

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.type) {
            queryParameters['type'] = requestParameters.type;
        }

        if (requestParameters.unanchored !== undefined) {
            queryParameters['unanchored'] = requestParameters.unanchored;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/extended/v1/tx`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TransactionResultsFromJSON(jsonValue));
    }

    /**
     * Retrieves all recently mined transactions  If using TypeScript, import typings for this response from our types package:  `import type { TransactionResults } from \'@stacks/stacks-blockchain-api-types\';` 
     * Get recent transactions
     */
    async getTransactionList(requestParameters: GetTransactionListRequest, initOverrides?: RequestInit): Promise<TransactionResults> {
        const response = await this.getTransactionListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves a list of all transactions within a block for a given block hash.
     * Transactions by block hash
     */
    async getTransactionsByBlockHashRaw(requestParameters: GetTransactionsByBlockHashRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<TransactionResults>> {
        if (requestParameters.blockHash === null || requestParameters.blockHash === undefined) {
            throw new runtime.RequiredError('blockHash','Required parameter requestParameters.blockHash was null or undefined when calling getTransactionsByBlockHash.');
        }

        const queryParameters: any = {};

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/extended/v1/tx/block/{block_hash}`.replace(`{${"block_hash"}}`, encodeURIComponent(String(requestParameters.blockHash))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TransactionResultsFromJSON(jsonValue));
    }

    /**
     * Retrieves a list of all transactions within a block for a given block hash.
     * Transactions by block hash
     */
    async getTransactionsByBlockHash(requestParameters: GetTransactionsByBlockHashRequest, initOverrides?: RequestInit): Promise<TransactionResults> {
        const response = await this.getTransactionsByBlockHashRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves all transactions within a block at a given height
     * Transactions by block height
     */
    async getTransactionsByBlockHeightRaw(requestParameters: GetTransactionsByBlockHeightRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<TransactionResults>> {
        if (requestParameters.height === null || requestParameters.height === undefined) {
            throw new runtime.RequiredError('height','Required parameter requestParameters.height was null or undefined when calling getTransactionsByBlockHeight.');
        }

        const queryParameters: any = {};

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.unanchored !== undefined) {
            queryParameters['unanchored'] = requestParameters.unanchored;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/extended/v1/tx/block_height/{height}`.replace(`{${"height"}}`, encodeURIComponent(String(requestParameters.height))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TransactionResultsFromJSON(jsonValue));
    }

    /**
     * Retrieves all transactions within a block at a given height
     * Transactions by block height
     */
    async getTransactionsByBlockHeight(requestParameters: GetTransactionsByBlockHeightRequest, initOverrides?: RequestInit): Promise<TransactionResults> {
        const response = await this.getTransactionsByBlockHeightRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves a list of transactions for a given list of transaction IDs  If using TypeScript, import typings for this response from our types package:  `import type { Transaction } from \'@stacks/stacks-blockchain-api-types\';` 
     * Get list of details for transactions
     */
    async getTxListDetailsRaw(requestParameters: GetTxListDetailsRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<{ [key: string]: object; }>> {
        if (requestParameters.txId === null || requestParameters.txId === undefined) {
            throw new runtime.RequiredError('txId','Required parameter requestParameters.txId was null or undefined when calling getTxListDetails.');
        }

        const queryParameters: any = {};

        if (requestParameters.txId) {
            queryParameters['tx_id'] = requestParameters.txId;
        }

        if (requestParameters.eventOffset !== undefined) {
            queryParameters['event_offset'] = requestParameters.eventOffset;
        }

        if (requestParameters.eventLimit !== undefined) {
            queryParameters['event_limit'] = requestParameters.eventLimit;
        }

        if (requestParameters.unanchored !== undefined) {
            queryParameters['unanchored'] = requestParameters.unanchored;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/extended/v1/tx/multiple`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Retrieves a list of transactions for a given list of transaction IDs  If using TypeScript, import typings for this response from our types package:  `import type { Transaction } from \'@stacks/stacks-blockchain-api-types\';` 
     * Get list of details for transactions
     */
    async getTxListDetails(requestParameters: GetTxListDetailsRequest, initOverrides?: RequestInit): Promise<{ [key: string]: object; }> {
        const response = await this.getTxListDetailsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Broadcasts raw transactions on the network. You can use the [@stacks/transactions](https://github.com/blockstack/stacks.js) project to generate a raw transaction payload.
     * Broadcast raw transaction
     */
    async postCoreNodeTransactionsRaw(requestParameters: PostCoreNodeTransactionsRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/octet-stream';

        const response = await this.request({
            path: `/v2/transactions`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Broadcasts raw transactions on the network. You can use the [@stacks/transactions](https://github.com/blockstack/stacks.js) project to generate a raw transaction payload.
     * Broadcast raw transaction
     */
    async postCoreNodeTransactions(requestParameters: PostCoreNodeTransactionsRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.postCoreNodeTransactionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
    * @export
    * @enum {string}
    */
export enum GetFilteredEventsTypeEnum {
    smart_contract_log = 'smart_contract_log',
    stx_lock = 'stx_lock',
    stx_asset = 'stx_asset',
    fungible_token_asset = 'fungible_token_asset',
    non_fungible_token_asset = 'non_fungible_token_asset'
}
/**
    * @export
    * @enum {string}
    */
export enum GetTransactionListTypeEnum {
    coinbase = 'coinbase',
    token_transfer = 'token_transfer',
    smart_contract = 'smart_contract',
    contract_call = 'contract_call',
    poison_microblock = 'poison_microblock'
}
